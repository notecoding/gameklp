<!DOCTYPE html>
<html lang="ko">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ë‹¤í¬ ë¡œê·¸ë¼ì´í¬ - ë¬´ê¸°&ìŠ¤í‚¬ ì‹œìŠ¤í…œ</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box
    }

    body {
      background: linear-gradient(135deg, #0f0c29, #302b63, #24243e);
      font-family: Arial, Helvetica, sans-serif;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      color: #fff;
      overflow: hidden
    }

    #gameContainer {
      background: rgba(0, 0, 0, .5);
      padding: 20px;
      border-radius: 20px;
      box-shadow: 0 0 50px rgba(138, 43, 226, .5);
      backdrop-filter: blur(10px);
      width: 1300px;
      max-width: 98vw
    }

    h1 {
      text-align: center;
      font-size: 36px;
      margin-bottom: 15px;
      text-shadow: 0 0 20px #ff006e;
      background: linear-gradient(90deg, #ff006e, #8338ec, #3a86ff);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text
    }

    #ui {
      display: flex;
      justify-content: space-between;
      margin-bottom: 15px;
      gap: 15px;
      flex-wrap: wrap
    }

    .stat {
      background: rgba(255, 255, 255, .1);
      padding: 10px 20px;
      border-radius: 10px;
      font-weight: bold;
      font-size: 16px;
      box-shadow: 0 4px 15px rgba(0, 0, 0, .3)
    }

    #hpBar {
      width: 200px;
      height: 25px;
      background: rgba(0, 0, 0, .5);
      border-radius: 12px;
      overflow: hidden;
      border: 2px solid #ff006e;
      box-shadow: 0 0 15px rgba(255, 0, 110, .5)
    }

    #hpFill {
      height: 100%;
      background: linear-gradient(90deg, #ff006e, #ff5e78);
      width: 100%;
      transition: width .3s;
      box-shadow: inset 0 0 10px rgba(255, 255, 255, .3)
    }

    #expBar {
      width: 200px;
      height: 15px;
      background: rgba(0, 0, 0, .5);
      border-radius: 8px;
      overflow: hidden;
      border: 2px solid #3a86ff;
      box-shadow: 0 0 15px rgba(58, 134, 255, .5)
    }

    #expFill {
      height: 100%;
      background: linear-gradient(90deg, #3a86ff, #06ffa5);
      width: 0%;
      transition: width .3s
    }

    #gameArea {
      display: flex;
      gap: 15px;
      justify-content: center;
      align-items: flex-start;
      margin: 0 auto;
    }

    #game {
      width: 800px;
      height: 500px;
      background: linear-gradient(180deg, #1a1a2e, #16213e);
      position: relative;
      border: 3px solid #8338ec;
      border-radius: 15px;
      overflow: hidden;
      box-shadow: inset 0 0 50px rgba(0, 0, 0, .5), 0 0 30px rgba(131, 56, 236, .3);
    }

    #player {
      width: 40px;
      height: 40px;
      background: linear-gradient(135deg, #ff006e, #8338ec);
      position: absolute;
      border-radius: 50%;
      box-shadow: 0 0 30px rgba(255, 0, 110, .8);
      transition: all .05s;
      z-index: 10;
      animation: playerPulse 1.5s ease-in-out infinite
    }

    @keyframes playerPulse {

      0%,
      100% {
        box-shadow: 0 0 30px rgba(255, 0, 110, .8)
      }

      50% {
        box-shadow: 0 0 50px rgba(255, 0, 110, 1)
      }
    }

    #player.flash {
      animation: playerFlash 0.2s ease-in-out 3;
    }

    @keyframes playerFlash {

      0%,
      100% {
        opacity: 1;
      }

      50% {
        opacity: 0.2;
      }
    }

    .enemy {
      width: 35px;
      height: 35px;
      background: linear-gradient(135deg, #ff4d4d, #c92a2a);
      position: absolute;
      border-radius: 50%;
      box-shadow: 0 0 20px rgba(255, 77, 77, .7);
      animation: enemyFloat 2s ease-in-out infinite
    }

    @keyframes enemyFloat {

      0%,
      100% {
        transform: translateY(0)
      }

      50% {
        transform: translateY(-10px)
      }
    }

    .boss {
      width: 60px;
      height: 60px;
      background: linear-gradient(135deg, #d946ef, #7e22ce);
      border: 3px solid #fff;
      animation: bossRotate 3s linear infinite
    }

    @keyframes bossRotate {
      from {
        transform: rotate(0)
      }

      to {
        transform: rotate(360deg)
      }
    }

    .elite {
      width: 45px;
      height: 45px;
      background: linear-gradient(135deg, #ffa500, #ff4500);
      border: 2px solid #ffd700;
      animation: eliteGlow 1.5s ease-in-out infinite
    }

    @keyframes eliteGlow {

      0%,
      100% {
        box-shadow: 0 0 20px rgba(255, 165, 0, .7)
      }

      50% {
        box-shadow: 0 0 40px rgba(255, 165, 0, 1)
      }
    }

    .item {
      width: 25px;
      height: 25px;
      background: linear-gradient(135deg, #ffd700, #ffed4e);
      position: absolute;
      border-radius: 50%;
      box-shadow: 0 0 20px rgba(255, 215, 0, .9);
      animation: itemSpin 2s linear infinite;
      z-index: 15;
    }

    @keyframes itemSpin {
      from {
        transform: rotate(0) scale(1)
      }

      50% {
        transform: rotate(180deg) scale(1.2)
      }

      to {
        transform: rotate(360deg) scale(1)
      }
    }

    .weapon-drop {
      width: 30px;
      height: 30px;
      position: absolute;
      border-radius: 8px;
      animation: weaponFloat 2s ease-in-out infinite;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 20px;
      border: 2px solid rgba(255, 255, 255, 0.5);
      box-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
      z-index: 15;
    }

    @keyframes weaponFloat {
      0%,
      100% {
        transform: translateY(0) rotate(0deg);
      }

      50% {
        transform: translateY(-15px) rotate(180deg);
      }
    }

    .projectile {
      width: 15px;
      height: 15px;
      background: radial-gradient(circle, #06ffa5, #3a86ff);
      position: absolute;
      border-radius: 50%;
      box-shadow: 0 0 15px #06ffa5
    }

    .damage {
      position: absolute;
      color: #ff006e;
      font-weight: bold;
      font-size: 20px;
      pointer-events: none;
      animation: damageFloat 1s ease-out forwards;
      text-shadow: 0 0 10px #000;
      z-index: 100
    }

    @keyframes damageFloat {
      0% {
        transform: translateY(0) scale(1);
        opacity: 1
      }

      100% {
        transform: translateY(-50px) scale(1.5);
        opacity: 0
      }
    }

    .heal {
      color: #06ffa5
    }

    .particle {
      position: absolute;
      width: 8px;
      height: 8px;
      background: #ff006e;
      border-radius: 50%;
      pointer-events: none;
      animation: particleExplode .8s ease-out forwards
    }

    @keyframes particleExplode {
      0% {
        transform: translate(0, 0) scale(1);
        opacity: 1
      }

      100% {
        transform: translate(var(--x), var(--y)) scale(0);
        opacity: 0
      }
    }

    #controls {
      text-align: center;
      margin-top: 15px;
      font-size: 14px;
      opacity: .8;
      background: rgba(255, 255, 255, .1);
      padding: 10px;
      border-radius: 10px
    }

    #gameOver,
    #menu,
    #settings,
    #leaderboard,
    #shop,
    #intro,
    #tutorial,
    #customize,
    #skillDialog {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, .95);
      padding: 30px;
      border-radius: 20px;
      text-align: center;
      display: none;
      z-index: 1000;
      border: 3px solid #ff006e;
      box-shadow: 0 0 50px rgba(255, 0, 110, .8);
      width: 630px;
      max-width: 90vw;
      max-height: 85vh;
      overflow-y: auto
    }

    #skillDialog {
      width: 700px;
      border-color: #ffd700;
      box-shadow: 0 0 50px rgba(255, 215, 0, .8);
    }

    .skill-choice {
      background: rgba(255, 255, 255, .08);
      border: 2px solid rgba(255, 215, 0, .3);
      border-radius: 15px;
      padding: 20px;
      margin: 15px 0;
      cursor: pointer;
      transition: all .3s;
    }

    .skill-choice:hover {
      background: rgba(255, 215, 0, .15);
      border-color: rgba(255, 215, 0, .6);
      transform: scale(1.05);
    }

    .skill-name {
      font-size: 20px;
      font-weight: bold;
      color: #ffd700;
      margin-bottom: 8px;
    }

    .skill-level {
      font-size: 14px;
      color: #06ffa5;
      margin-bottom: 8px;
    }

    .skill-desc {
      font-size: 14px;
      opacity: 0.9;
      line-height: 1.4;
    }

    .skill-fusion {
      background: linear-gradient(135deg, #d946ef, #7e22ce);
      border-color: #d946ef;
    }

    .skill-fusion:hover {
      background: linear-gradient(135deg, #e946ff, #8e32de);
      border-color: #e946ff;
    }

    #weaponUI {
      background: rgba(0, 0, 0, 0.7);
      border: 2px solid #8338ec;
      border-radius: 10px;
      padding: 10px;
      min-width: 200px;
      max-width: 250px;
      max-height: 500px;
      overflow-y: auto;
    }

    .weapon-slot {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 8px;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 8px;
      margin: 5px 0;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .weapon-icon {
      width: 30px;
      height: 30px;
      border-radius: 6px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
      border: 2px solid rgba(255, 255, 255, 0.3);
    }

    .weapon-info {
      flex: 1;
      text-align: left;
    }

    .weapon-name {
      font-size: 14px;
      font-weight: bold;
      color: #ffd700;
    }

    .weapon-stack {
      font-size: 12px;
      color: #06ffa5;
    }

    #skillsUI {
      background: rgba(0, 0, 0, 0.7);
      border: 2px solid #8338ec;
      border-radius: 10px;
      padding: 10px;
      min-width: 200px;
      max-width: 250px;
      max-height: 500px;
      overflow-y: auto;
    }

    #weaponUI::-webkit-scrollbar,
    #skillsUI::-webkit-scrollbar {
      width: 6px;
    }

    #weaponUI::-webkit-scrollbar-track,
    #skillsUI::-webkit-scrollbar-track {
      background: rgba(255, 255, 255, .1);
      border-radius: 10px;
    }

    #weaponUI::-webkit-scrollbar-thumb,
    #skillsUI::-webkit-scrollbar-thumb {
      background: rgba(131, 56, 236, .6);
      border-radius: 10px;
    }

    #weaponUI::-webkit-scrollbar-thumb:hover,
    #skillsUI::-webkit-scrollbar-thumb:hover {
      background: rgba(131, 56, 236, .8);
    }

    .skill-bar-name {
      font-size: 11px;
      flex: 1;
      text-align: left;
    }

    .skill-bar-level {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 6px;
      margin: 4px 0;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .skill-bar-name {
      font-size: 12px;
      font-weight: bold;
      margin-bottom: 8px;
      text-align: center;
      color: #ffd700;
    }

    .skill-bar {
      font-size: 11px;
      color: #06ffa5;
      font-weight: bold;
    }

    #gameOver::-webkit-scrollbar,
    #menu::-webkit-scrollbar,
    #settings::-webkit-scrollbar,
    #leaderboard::-webkit-scrollbar,
    #shop::-webkit-scrollbar,
    #intro::-webkit-scrollbar,
    #tutorial::-webkit-scrollbar,
    #customize::-webkit-scrollbar,
    #skillDialog::-webkit-scrollbar {
      width: 8px
    }

    #gameOver::-webkit-scrollbar-track,
    #menu::-webkit-scrollbar-track,
    #settings::-webkit-scrollbar-track,
    #leaderboard::-webkit-scrollbar-track,
    #shop::-webkit-scrollbar-track,
    #intro::-webkit-scrollbar-track,
    #tutorial::-webkit-scrollbar-track,
    #customize::-webkit-scrollbar-track,
    #skillDialog::-webkit-scrollbar-track {
      background: rgba(255, 255, 255, .1);
      border-radius: 10px
    }

    #gameOver::-webkit-scrollbar-thumb,
    #menu::-webkit-scrollbar-thumb,
    #settings::-webkit-scrollbar-thumb,
    #leaderboard::-webkit-scrollbar-thumb,
    #shop::-webkit-scrollbar-thumb,
    #intro::-webkit-scrollbar-thumb,
    #tutorial::-webkit-scrollbar-thumb,
    #customize::-webkit-scrollbar-thumb,
    #skillDialog::-webkit-scrollbar-thumb {
      background: rgba(255, 0, 110, .6);
      border-radius: 10px
    }

    #gameOver::-webkit-scrollbar-thumb:hover,
    #menu::-webkit-scrollbar-thumb:hover,
    #settings::-webkit-scrollbar-thumb:hover,
    #leaderboard::-webkit-scrollbar-thumb:hover,
    #shop::-webkit-scrollbar-thumb:hover,
    #intro::-webkit-scrollbar-thumb:hover,
    #tutorial::-webkit-scrollbar-thumb:hover,
    #customize::-webkit-scrollbar-thumb:hover,
    #skillDialog::-webkit-scrollbar-thumb:hover {
      background: rgba(255, 0, 110, .8)
    }

    #intro {
      width: 700px;
      max-width: 90vw;
      animation: introFade 1s ease-in
    }

    @keyframes introFade {
      from {
        opacity: 0
      }

      to {
        opacity: 1
      }
    }

    .intro-logo {
      font-size: 64px;
      margin: 20px 0;
      text-shadow: 0 0 30px #ff006e;
      animation: logoFloat 3s ease-in-out infinite
    }

    @keyframes logoFloat {

      0%,
      100% {
        transform: translateY(0)
      }

      50% {
        transform: translateY(-20px)
      }
    }

    #gameOver h2 {
      font-size: 40px;
      margin-bottom: 10px;
      color: #ff006e;
      text-shadow: 0 0 20px #ff006e
    }

    .modal-title {
      font-size: 28px;
      margin-bottom: 10px;
      color: #ffd700;
      text-shadow: 0 0 12px #ffd700
    }

    .modal-btn {
      padding: 12px 28px;
      font-size: 16px;
      background: linear-gradient(135deg, #ff006e, #8338ec);
      color: #fff;
      border: none;
      border-radius: 50px;
      cursor: pointer;
      font-weight: bold;
      margin: 8px 6px;
      box-shadow: 0 5px 20px rgba(255, 0, 110, .5);
      transition: all .25s
    }

    .modal-btn:hover {
      transform: scale(1.06)
    }

    .modal-btn:disabled {
      opacity: .5;
      cursor: not-allowed;
      transform: none
    }

    #combo {
      position: absolute;
      top: 20px;
      right: 20px;
      font-size: 32px;
      font-weight: bold;
      color: #ffd700;
      text-shadow: 0 0 20px #ffd700
    }

    .enemyHpBar {
      position: absolute;
      top: -8px;
      left: 0;
      width: 100%;
      height: 5px;
      background: rgba(0, 0, 0, .5);
      border-radius: 3px
    }

    .enemyHpFill {
      height: 100%;
      background: linear-gradient(90deg, #ff4d4d, #ff8787);
      border-radius: 3px;
      transition: width .2s
    }

    #minimap {
      position: absolute;
      bottom: 10px;
      right: 10px;
      width: 150px;
      height: 100px;
      background: rgba(0, 0, 0, .7);
      border: 2px solid #8338ec;
      border-radius: 10px
    }

    .minimapDot {
      position: absolute;
      width: 5px;
      height: 5px;
      border-radius: 50%
    }

    .playerDot {
      background: #ff006e;
      box-shadow: 0 0 5px #ff006e
    }

    .enemyDot {
      background: #ff4d4d
    }

    .eliteDot {
      background: #ffa500
    }

    .bossDot {
      background: #d946ef;
      width: 8px;
      height: 8px
    }

    #waveWarning {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 48px;
      font-weight: bold;
      color: #ff006e;
      text-shadow: 0 0 30px #ff006e;
      display: none;
      z-index: 999
    }

    .badge {
      display: inline-block;
      background: rgba(255, 255, 255, .1);
      border: 1px solid rgba(255, 255, 255, .2);
      padding: 6px 10px;
      border-radius: 999px;
      margin: 3px 4px;
      font-size: 13px
    }

    .row {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      justify-content: center
    }

    .input {
      padding: 10px 14px;
      border-radius: 10px;
      border: 1px solid rgba(255, 255, 255, .2);
      background: rgba(255, 255, 255, .08);
      color: #fff;
      outline: none
    }

    .select {
      padding: 10px 14px;
      border-radius: 10px;
      border: 1px solid rgba(255, 255, 255, .2);
      background: rgba(255, 255, 255, .08);
      color: #fff;
      outline: none
    }

    .range {
      width: 220px
    }

    .small {
      font-size: 12px;
      opacity: .8
    }

    hr {
      border: none;
      border-top: 1px solid rgba(255, 255, 255, .15);
      margin: 12px 0
    }

    #pauseOverlay {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.7);
      backdrop-filter: blur(5px);
      display: none;
      z-index: 900;
      justify-content: center;
      align-items: center;
      font-size: 48px;
      font-weight: bold;
      color: #ffd700;
      text-shadow: 0 0 30px #ffd700;
    }

    .stat.expected {
      background: rgba(255, 215, 0, .15);
      border: 1px solid rgba(255, 215, 0, .3)
    }

    .shop-section-title {
      margin: 8px 0;
      font-weight: bold
    }

    .shop-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px
    }

    @media (max-width: 768px) {
      .shop-grid {
        grid-template-columns: 1fr
      }

      #intro {
        width: 90vw
      }

      h1 {
        font-size: 24px
      }

      #gameContainer {
        padding: 10px
      }

      .modal-title {
        font-size: 22px
      }
    }

    .up-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      background: rgba(255, 255, 255, .08);
      border: 1px solid rgba(255, 255, 255, .15);
      border-radius: 12px;
      padding: 10px
    }

    .up-left {
      display: flex;
      gap: 8px;
      align-items: center
    }

    .up-name {
      font-weight: bold
    }

    .up-level {
      font-size: 12px;
      opacity: .8
    }

    .up-cost {
      font-size: 12px;
      opacity: .9
    }

    .wall {
      position: absolute;
      background: linear-gradient(135deg, #4a4a4a, #2a2a2a);
      border: 2px solid #666;
      border-radius: 8px;
      box-shadow: inset 0 0 20px rgba(0, 0, 0, .5)
    }

    .trap {
      position: absolute;
      background: radial-gradient(circle, #ff0000, #8b0000);
      border: 2px solid #ff4444;
      border-radius: 50%;
      animation: trapPulse 2s ease-in-out infinite
    }

    @keyframes trapPulse {

      0%,
      100% {
        opacity: .6;
        transform: scale(1)
      }

      50% {
        opacity: 1;
        transform: scale(1.1)
      }
    }

    .customize-section {
      margin: 15px 0;
      text-align: left
    }

    .customize-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
      gap: 10px;
      margin-top: 10px
    }

    .customize-item {
      padding: 10px;
      background: rgba(255, 255, 255, .08);
      border: 2px solid rgba(255, 255, 255, .2);
      border-radius: 10px;
      cursor: pointer;
      transition: all .2s;
      text-align: center
    }

    .customize-item:hover {
      background: rgba(255, 255, 255, .15);
      transform: scale(1.05)
    }

    .customize-item.selected {
      border-color: #ffd700;
      background: rgba(255, 215, 0, .2)
    }

    .tutorial-step {
      margin: 15px 0;
      padding: 15px;
      background: rgba(255, 255, 255, .05);
      border-left: 4px solid #8338ec;
      text-align: left
    }

    .tutorial-step h3 {
      color: #ffd700;
      margin-bottom: 8px
    }

    .shield-visual {
      position: absolute;
      width: 50px;
      height: 50px;
      border: 3px solid rgba(6, 255, 165, 0.6);
      border-radius: 50%;
      top: -5px;
      left: -5px;
      animation: shieldPulse 1s ease-in-out infinite;
      pointer-events: none;
    }

    @keyframes shieldPulse {
      0%,
      100% {
        opacity: 0.6;
        transform: scale(1);
      }

      50% {
        opacity: 1;
        transform: scale(1.1);
      }
    }
  </style>
</head>

<body>
  <audio id="bgmAudio" loop>
    <source src="bgm.wav" type="audio/wav">
  </audio>
  <div id="gameContainer">
    <h1>âš”ï¸ ë‹¤í¬ ë¡œê·¸ë¼ì´í¬ âš”ï¸</h1>

    <div id="ui">
      <div>
        <div class="stat">ë‹‰ë„¤ì„: <span id="nickLabel">Guest</span></div>
        <div class="stat">LV: <span id="level">1</span></div>
        <div id="hpBar">
          <div id="hpFill"></div>
        </div>
        <div style="font-size:12px;margin-top:5px">HP: <span id="hpText">100/100</span></div>
      </div>
      <div>
        <div class="stat">ìŠ¤í…Œì´ì§€: <span id="stage">1</span></div>
        <div id="expBar">
          <div id="expFill"></div>
        </div>
        <div style="font-size:12px;margin-top:5px">EXP: <span id="expText">0/100</span></div>
      </div>
      <div>
        <div class="stat">í‚¬: <span id="kills">0</span></div>
        <div class="stat">ê³µê²©ë ¥: <span id="atk">20</span></div>
        <div class="stat">ì ìˆ˜: <span id="score">0</span></div>
        <div class="stat">ìƒì¡´: <span id="survive">0s</span></div>
        <div class="stat">ê³¨ë“œ: <span id="gold">0</span></div>
        <div class="stat expected">íšë“ì˜ˆìƒ: <span id="expectedGold">0G</span></div>
      </div>
    </div>

    <div id="gameArea">
      <div id="skillsUI"></div>
      
      <div id="game">
        <div id="player"></div>
        <div id="minimap"></div>
        <div id="waveWarning">âš ï¸ ìƒˆë¡œìš´ ì›¨ì´ë¸Œ! âš ï¸</div>
        <div id="pauseOverlay">â¸¨ ì¼ì‹œì •ì§€</div>
      </div>
      
      <div id="weaponUI"></div>
    </div>

    <div id="controls">
      â¬†ï¸â¬‡ï¸â¬…ï¸â¡ï¸ ì´ë™ | SPACE ê³µê²© | A íŠ¹ìˆ˜ê³µê²© | S ëŒ€ì‹œ | P ì¼ì‹œì •ì§€ | ESC ë©”ë‰´/ë’¤ë¡œ
    </div>

    <div id="intro">
        <div class="intro-logo">âš”ï¸ ë‹¤í¬ ë¡œê·¸ë¼ì´í¬ âš”ï¸</div>
        <p style="font-size:18px;margin:20px 0;line-height:1.6">
          ì–´ë‘ ì˜ ë˜ì „ì— ì˜¤ì‹  ê²ƒì„ í™˜ì˜í•©ë‹ˆë‹¤.<br>
          ê°•ë ¥í•œ ì ë“¤ê³¼ ì‹¸ìš°ë©° ìƒì¡´í•˜ì„¸ìš”.<br>
          ì£½ìŒì€ ëì´ ì•„ë‹Œ ìƒˆë¡œìš´ ì‹œì‘ì…ë‹ˆë‹¤.
        </p>
        <div class="small" style="margin:20px 0">ver 3.0 - ë¬´ê¸°&ìŠ¤í‚¬ ì‹œìŠ¤í…œ</div>
        <button class="modal-btn" id="btnIntroStart">ì‹œì‘í•˜ê¸°</button>
        <button class="modal-btn" id="btnIntroTutorial">íŠœí† ë¦¬ì–¼</button>
      </div>

      <div id="tutorial">
        <div class="modal-title">ğŸ“š íŠœí† ë¦¬ì–¼</div>
        <div class="tutorial-step">
          <h3>ğŸ® ê¸°ë³¸ ì¡°ì‘</h3>
          <p>â€¢ ë°©í–¥í‚¤: ìºë¦­í„° ì´ë™<br>
            â€¢ SPACE: ê¸°ë³¸ ê³µê²© (ê°€ì¥ ê°€ê¹Œìš´ ì  ìë™ ì¡°ì¤€)<br>
            â€¢ A: íŠ¹ìˆ˜ ê³µê²© (ì „ë°©ìœ„ íƒ„ë§‰)<br>
            â€¢ S: ëŒ€ì‹œ (ì¿¨ë‹¤ìš´ ìˆìŒ)</p>
        </div>
        <div class="tutorial-step">
          <h3>âš”ï¸ ë¬´ê¸° ì‹œìŠ¤í…œ</h3>
          <p>â€¢ ë§µì— ë–¨ì–´ì§„ ë¬´ê¸°ë¥¼ íšë“í•˜ì„¸ìš”<br>
            â€¢ ë¬´ê¸°ëŠ” ì¤‘ë³µ íšë“ ì‹œ íš¨ê³¼ê°€ ì¤‘ì²©ë©ë‹ˆë‹¤<br>
            â€¢ ì™¼ìª½ í•˜ë‹¨ì—ì„œ ë³´ìœ  ë¬´ê¸° í™•ì¸ ê°€ëŠ¥<br>
            â€¢ ë¬´ê¸°ë§ˆë‹¤ ê³ ìœ í•œ íš¨ê³¼ê°€ ìˆìŠµë‹ˆë‹¤</p>
        </div>
        <div class="tutorial-step">
          <h3>âœ¨ ìŠ¤í‚¬ ì‹œìŠ¤í…œ</h3>
          <p>â€¢ ë ˆë²¨ì—… ì‹œ 3ê°€ì§€ ìŠ¤í‚¬ ì¤‘ ì„ íƒ<br>
            â€¢ ìŠ¤í‚¬ì€ ìµœëŒ€ 10ë ˆë²¨ê¹Œì§€ ê°•í™” ê°€ëŠ¥<br>
            â€¢ íŠ¹ì • ìŠ¤í‚¬ 2ê°œê°€ 10ë ˆë²¨ ì´ìƒì´ë©´ ìœµí•© ìŠ¤í‚¬ ë“±ì¥<br>
            â€¢ ì™¼ìª½ ìƒë‹¨ì—ì„œ ë³´ìœ  ìŠ¤í‚¬ í™•ì¸ ê°€ëŠ¥</p>
        </div>
        <div class="tutorial-step">
          <h3>ğŸ¯ ì „íˆ¬ ì‹œìŠ¤í…œ</h3>
          <p>â€¢ ì ì„ ì—°ì†ìœ¼ë¡œ ì²˜ì¹˜í•˜ë©´ ì½¤ë³´ ë°œë™!<br>
            â€¢ ì½¤ë³´ê°€ ë†’ì„ìˆ˜ë¡ ë” ë§ì€ ì ìˆ˜ íšë“<br>
            â€¢ 5ìŠ¤í…Œì´ì§€ë§ˆë‹¤ ê°•ë ¥í•œ ë³´ìŠ¤ ë“±ì¥<br>
            â€¢ ì—˜ë¦¬íŠ¸ ëª¬ìŠ¤í„°ëŠ” ë†’ì€ ë³´ìƒ ì œê³µ</p>
        </div>
        <button class="modal-btn" id="btnTutorialBack">ë’¤ë¡œ</button>
      </div>

      <div id="menu">
        <div class="modal-title">ë©”ì¸ ë©”ë‰´</div>
        <div class="row" style="justify-content:center;margin:10px 0">
          <input id="nickInput" class="input" placeholder="ë‹‰ë„¤ì„" maxlength="12" />
          <select id="charSelect" class="select" title="ìºë¦­í„° ì„ íƒ">
            <option value="basic">ê¸°ë³¸ ì „ì‚¬ (ë¬´ë£Œ)</option>
            <option value="assassin">ì•”ì‚´ì (í•´ê¸ˆ: 200G)</option>
            <option value="paladin">íŒ”ë¼ë”˜ (í•´ê¸ˆ: 500G)</option>
          </select>
        </div>
        <div class="small">â€» ìºë¦­í„°ëŠ” ìƒì ì—ì„œ í•´ê¸ˆ í›„ ì„ íƒ ê°€ëŠ¥</div>
        <hr />
        <button class="modal-btn" id="btnStart">ê²Œì„ ì‹œì‘</button>
        <button class="modal-btn" id="btnCustomize">ì»¤ìŠ¤í„°ë§ˆì´ì§•</button>
        <button class="modal-btn" id="btnShop">ìƒì /ê°•í™”</button>
        <button class="modal-btn" id="btnLeaderboard">ë­í‚¹</button>
        <button class="modal-btn" id="btnSettings">ì„¤ì •</button>
      </div>

      <div id="customize">
        <div class="modal-title">âœ¨ ì»¤ìŠ¤í„°ë§ˆì´ì§•</div>

        <div class="customize-section">
          <h3>ğŸ¨ í”Œë ˆì´ì–´ ìƒ‰ìƒ</h3>
          <div class="customize-grid" id="colorGrid"></div>
        </div>

        <div class="customize-section">
          <h3>ğŸ—¡ï¸ ë¬´ê¸° ìŠ¤íƒ€ì¼</h3>
          <div class="customize-grid" id="weaponGrid"></div>
        </div>

        <div class="customize-section">
          <h3>âœ¨ ì´í™íŠ¸</h3>
          <div class="customize-grid" id="effectGrid"></div>
        </div>

        <hr />
        <button class="modal-btn" id="btnCustomizeBack">ë’¤ë¡œ</button>
      </div>

      <div id="settings">
        <div class="modal-title">ì„¤ì •</div>
        <div style="margin:10px 0">
          BGM ìŒëŸ‰: <input type="range" id="bgmVol" class="range" min="0" max="1" step="0.01">
        </div>
        <div style="margin:10px 0">
          SFX ìŒëŸ‰: <input type="range" id="sfxVol" class="range" min="0" max="1" step="0.01">
        </div>
        <div class="small">ESCë¡œ ë’¤ë¡œ, Pë¡œ ì¼ì‹œì •ì§€</div>
        <hr />
        <button class="modal-btn" id="btnSettingsBack">ë’¤ë¡œ</button>
        <button class="modal-btn" id="btnResumeGame" style="display:none">ê²Œì„ ì¬ê°œ</button>
      </div>

      <div id="leaderboard">
        <div class="modal-title">ë­í‚¹ (TOP 10)</div>
        <div id="rankList" style="text-align:left;max-height:260px;overflow:auto"></div>
        <hr />
        <button class="modal-btn" id="btnLbBack">ë’¤ë¡œ</button>
      </div>

      <div id="shop">
        <div class="modal-title">ìƒì  (ìºë¦­í„° í•´ê¸ˆ & ê³¨ë“œ ê°•í™”)</div>

        <div class="shop-section-title">â‘  ìºë¦­í„° í•´ê¸ˆ/ì„ íƒ</div>
        <div id="shopList" class="shop-grid"></div>

        <div class="shop-section-title">â‘¡ ê³¨ë“œ ê°•í™” (ì˜êµ¬ ìŠ¤íƒ¯)</div>
        <div id="upgradeList"></div>
        <div class="small" style="margin-top:6px">â€» ê°•í™”ëŠ” ì˜êµ¬ ì ìš©ë˜ë©°, ìƒˆ ê²Œì„ ì‹œì‘ ì‹œ ìë™ ë°˜ì˜ë©ë‹ˆë‹¤.</div>

        <hr />
        <button class="modal-btn" id="btnShopBack">ë’¤ë¡œ</button>
      </div>

      <div id="skillDialog">
        <div class="modal-title">ğŸŒŸ ë ˆë²¨ì—…! ìŠ¤í‚¬ ì„ íƒ ğŸŒŸ</div>
        <div id="skillChoices"></div>
      </div>

      <div id="gameOver">
        <h2>ğŸ’€ íŒ¨ë°° ğŸ’€</h2>
        <p id="finalStats"></p>
        <div id="earnedGold" style="margin:6px 0"></div>
        <div id="achieveRow" class="row"></div>
        <button id="restartBtn" class="modal-btn">ë‹¤ì‹œ ì‹œì‘</button>
        <button id="goMenuBtn" class="modal-btn">ë©”ë‰´ë¡œ</button>
      </div>
    </div>

    
  </div>

  <script>
    const game = document.getElementById('game');
    const playerEl = document.getElementById('player');
    const minimap = document.getElementById('minimap');
    const pauseOverlay = document.getElementById('pauseOverlay');
    const weaponUIEl = document.getElementById('weaponUI');
    const skillsUIEl = document.getElementById('skillsUI');
    
    const UI = {
      hpText: document.getElementById('hpText'),
      hpFill: document.getElementById('hpFill'),
      level: document.getElementById('level'),
      expText: document.getElementById('expText'),
      expFill: document.getElementById('expFill'),
      stage: document.getElementById('stage'),
      atk: document.getElementById('atk'),
      kills: document.getElementById('kills'),
      score: document.getElementById('score'),
      survive: document.getElementById('survive'),
      gold: document.getElementById('gold'),
      expectedGold: document.getElementById('expectedGold'),
      nickLabel: document.getElementById('nickLabel')
    };
    
    const MODALS = {
      intro: document.getElementById('intro'),
      tutorial: document.getElementById('tutorial'),
      menu: document.getElementById('menu'),
      settings: document.getElementById('settings'),
      leaderboard: document.getElementById('leaderboard'),
      shop: document.getElementById('shop'),
      customize: document.getElementById('customize'),
      gameOver: document.getElementById('gameOver'),
      waveWarning: document.getElementById('waveWarning'),
      skillDialog: document.getElementById('skillDialog')
    };
    
    const BTN = {
      introStart: document.getElementById('btnIntroStart'),
      introTutorial: document.getElementById('btnIntroTutorial'),
      tutorialBack: document.getElementById('btnTutorialBack'),
      start: document.getElementById('btnStart'),
      customize: document.getElementById('btnCustomize'),
      shop: document.getElementById('btnShop'),
      leaderboard: document.getElementById('btnLeaderboard'),
      settings: document.getElementById('btnSettings'),
      lbBack: document.getElementById('btnLbBack'),
      shopBack: document.getElementById('btnShopBack'),
      customizeBack: document.getElementById('btnCustomizeBack'),
      settingsBack: document.getElementById('btnSettingsBack'),
      resumeGame: document.getElementById('btnResumeGame'),
      restart: document.getElementById('restartBtn'),
      goMenu: document.getElementById('goMenuBtn')
    };
    
    const INPUTS = {
      nick: document.getElementById('nickInput'),
      char: document.getElementById('charSelect'),
      bgmVol: document.getElementById('bgmVol'),
      sfxVol: document.getElementById('sfxVol')
    };
    
    const LISTS = {
      rank: document.getElementById('rankList'),
      shop: document.getElementById('shopList'),
      upgrade: document.getElementById('upgradeList'),
      achieveRow: document.getElementById('achieveRow'),
      earnedGold: document.getElementById('earnedGold'),
      colorGrid: document.getElementById('colorGrid'),
      weaponGrid: document.getElementById('weaponGrid'),
      effectGrid: document.getElementById('effectGrid'),
      skillChoices: document.getElementById('skillChoices')
    };

    const LS_KEYS = {
      save: 'dl_save_v3',
      scores: 'dl_scores_v1',
      settings: 'dl_settings_v1'
    };

    // ë¬´ê¸° ì •ì˜
    const WEAPONS = {
      sword: {
        id: 'sword',
        name: 'ê²€',
        icon: 'âš”ï¸',
        color: '#c0c0c0',
        effect: 'atk',
        value: 5,
        desc: 'ê³µê²©ë ¥ +5'
      },
      bow: {
        id: 'bow',
        name: 'í™œ',
        icon: 'ğŸ¹',
        color: '#8b4513',
        effect: 'speed',
        value: 0.3,
        desc: 'ì´ë™ì†ë„ +0.3'
      },
      staff: {
        id: 'staff',
        name: 'ì§€íŒ¡ì´',
        icon: 'ğŸª„',
        color: '#9370db',
        effect: 'projSpeed',
        value: 2,
        desc: 'íˆ¬ì‚¬ì²´ ì†ë„ +2'
      },
      axe: {
        id: 'axe',
        name: 'ë„ë¼',
        icon: 'ğŸª“',
        color: '#8b0000',
        effect: 'atk',
        value: 8,
        desc: 'ê³µê²©ë ¥ +8'
      },
      dagger: {
        id: 'dagger',
        name: 'ë‹¨ê²€',
        icon: 'ğŸ—¡ï¸',
        color: '#696969',
        effect: 'atkSpeed',
        value: 0.1,
        desc: 'ê³µê²©ì†ë„ +10%'
      }
    };

    // ìŠ¤í‚¬ ì •ì˜
    const SKILLS = {
      powerBoost: {
        id: 'powerBoost',
        name: 'ê³µê²©ë ¥ ê°•í™”',
        icon: 'âš¡',
        maxLevel: 20,
        getValue: (lv) => lv * 3,
        desc: (lv) => `ê³µê²©ë ¥ +${lv * 3}`
      },
      lifeSteal: {
        id: 'lifeSteal',
        name: 'í¡í˜ˆ',
        icon: 'ğŸ©¸',
        maxLevel: 20,
        getValue: (lv) => lv * 2,
        desc: (lv) => `ì  ì²˜ì¹˜ ì‹œ HP ${lv * 2} íšŒë³µ`
      },
      speedBoost: {
        id: 'speedBoost',
        name: 'ì´ë™ì†ë„ ê°•í™”',
        icon: 'ğŸ’¨',
        maxLevel: 20,
        getValue: (lv) => lv * 0.2,
        desc: (lv) => `ì´ë™ì†ë„ +${(lv * 0.2).toFixed(1)}`
      },
      shield: {
        id: 'shield',
        name: 'ë°©ì–´ë§‰',
        icon: 'ğŸ›¡ï¸',
        maxLevel: 20,
        getValue: (lv) => lv * 10,
        desc: (lv) => `ìµœëŒ€ ì²´ë ¥ +${lv * 10}`
      },
      criticalHit: {
        id: 'criticalHit',
        name: 'ì¹˜ëª…íƒ€',
        icon: 'ğŸ’¥',
        maxLevel: 20,
        getValue: (lv) => lv * 5,
        desc: (lv) => `${lv * 5}% í™•ë¥ ë¡œ 2ë°° ë°ë¯¸ì§€`
      },
      multiShot: {
        id: 'multiShot',
        name: 'ë‹¤ì¤‘ ë°œì‚¬',
        icon: 'ğŸ¯',
        maxLevel: 20,
        getValue: (lv) => Math.floor(lv / 3),
        desc: (lv) => `íˆ¬ì‚¬ì²´ +${Math.floor(lv / 3)}ê°œ`
      },
      penetration: {
        id: 'penetration',
        name: 'ê´€í†µ',
        icon: 'ğŸ”±',
        maxLevel: 20,
        getValue: (lv) => lv,
        desc: (lv) => `íˆ¬ì‚¬ì²´ê°€ ì  ${lv}ëª… ê´€í†µ`
      },
      rage: {
        id: 'rage',
        name: 'ë¶„ë…¸',
        icon: 'ğŸ˜¡',
        maxLevel: 20,
        getValue: (lv) => lv * 0.5,
        desc: (lv) => `ì²´ë ¥ 50% ì´í•˜ì‹œ ê³µê²©ë ¥ +${lv * 0.5}%`
      },
      harmony: {
        id: 'harmony',
        name: 'ì¡°í™”',
        icon: 'â˜¯ï¸',
        maxLevel: 20,
        getValue: (lv) => lv * 2,
        desc: (lv) => `ì´ˆë‹¹ HP ${(lv * 2).toFixed(1)} ì¬ìƒ`
      }
    };

    // ìœµí•© ìŠ¤í‚¬ ì •ì˜
    const FUSION_SKILLS = {
      berserker: {
        id: 'berserker',
        name: 'ê´‘ì „ì‚¬',
        icon: 'âš”ï¸ğŸ©¸',
        requires: ['powerBoost', 'lifeSteal'],
        requiredLevel: 10,
        maxLevel: 10,
        getValue: (lv) => lv * 10,
        desc: (lv) => `ê³µê²©ë ¥ +${lv * 10}, ì  ì²˜ì¹˜ ì‹œ HP ${lv * 5} íšŒë³µ, ê³µê²©ì†ë„ +20%`
      },
      fortress: {
        id: 'fortress',
        name: 'ìš”ìƒˆ',
        icon: 'ğŸ›¡ï¸ğŸ’¨',
        requires: ['shield', 'speedBoost'],
        requiredLevel: 10,
        maxLevel: 10,
        getValue: (lv) => lv * 20,
        desc: (lv) => `ìµœëŒ€ HP +${lv * 20}, ì´ë™ì†ë„ +${(lv * 0.3).toFixed(1)}, í”¼ê²© ì‹œ 3ì´ˆê°„ ë¬´ì `
      },
      destroyer: {
        id: 'destroyer',
        name: 'íŒŒê´´ì',
        icon: 'ğŸ’¥ğŸ”±',
        requires: ['criticalHit', 'penetration'],
        requiredLevel: 10,
        maxLevel: 10,
        getValue: (lv) => lv * 10,
        desc: (lv) => `${lv * 10}% í™•ë¥ ë¡œ 3ë°° ì¹˜ëª…íƒ€, ëª¨ë“  íˆ¬ì‚¬ì²´ê°€ ì  5ëª… ê´€í†µ`
      }
    };

    const CHARACTERS = {
      basic: { name: 'ê¸°ë³¸ ì „ì‚¬', cost: 0, colorStart: '#ff006e', colorEnd: '#8338ec', size: 40, baseHp: 100, baseAtk: 20, speed: 4, projCount: 8 },
      assassin: { name: 'ì•”ì‚´ì', cost: 200, colorStart: '#06ffa5', colorEnd: '#3a86ff', size: 34, baseHp: 80, baseAtk: 25, speed: 5.3, projCount: 12 },
      paladin: { name: 'íŒ”ë¼ë”˜', cost: 500, colorStart: '#ffd700', colorEnd: '#ff9f1c', size: 44, baseHp: 140, baseAtk: 18, speed: 3.6, projCount: 6 }
    };

    const UPGRADE_DEFS = {
      atk: { name: 'ê³µê²©ë ¥', perLevel: 2, costBase: 100, costScale: 1.5, max: 50, icon: 'ğŸ—¡ï¸' },
      hp: { name: 'ì²´ë ¥', perLevel: 10, costBase: 100, costScale: 1.45, max: 50, icon: 'â¤ï¸' },
      spd: { name: 'ì´ì†', perLevel: 0.1, costBase: 120, costScale: 1.6, max: 40, icon: 'âš¡' }
    };

    const ACHIEVEMENTS = [
      { id: 'first_kill', name: 'ì²« ì²˜ì¹˜', cond: s => s.kills >= 1 },
      { id: 'stage5', name: 'ìŠ¤í…Œì´ì§€ 5 ëŒíŒŒ', cond: s => s.stage >= 5 },
      { id: 'survive_60', name: 'ìƒì¡´ 60ì´ˆ', cond: s => s.surviveSec >= 60 },
      { id: 'boss_kill', name: 'ë³´ìŠ¤ ê²©íŒŒ', cond: s => s.bossKills >= 1 },
      { id: 'elite_kill', name: 'ì—˜ë¦¬íŠ¸ ì²˜ì¹˜', cond: s => s.eliteKills >= 1 },
      { id: 'kill_100', name: '100í‚¬ ë‹¬ì„±', cond: s => s.kills >= 100 }
    ];

    const CUSTOMIZATION = {
      colors: [
        { id: 'red', name: 'ë ˆë“œ', start: '#ff006e', end: '#8338ec' },
        { id: 'green', name: 'ê·¸ë¦°', start: '#06ffa5', end: '#3a86ff' },
        { id: 'gold', name: 'ê³¨ë“œ', start: '#ffd700', end: '#ff9f1c' },
        { id: 'purple', name: 'í¼í”Œ', start: '#d946ef', end: '#7e22ce' },
        { id: 'cyan', name: 'ì‹œì•ˆ', start: '#00ffff', end: '#0080ff' }
      ],
      weapons: [
        { id: 'normal', name: 'ê¸°ë³¸', color: '#06ffa5' },
        { id: 'fire', name: 'í™”ì—¼', color: '#ff4500' },
        { id: 'ice', name: 'ë¹™ê²°', color: '#00bfff' },
        { id: 'poison', name: 'ë…', color: '#00ff00' }
      ],
      effects: [
        { id: 'normal', name: 'ê¸°ë³¸' },
        { id: 'trail', name: 'ì”ìƒ' },
        { id: 'glow', name: 'ë¹›ë‚¨' }
      ]
    };

    let state = {
      screen: 'intro',
      running: false,
      keys: {},
      playerX: 380, playerY: 230,
      hp: 100, maxHp: 100, atk: 20, speed: 4,
      level: 1, exp: 0, maxExp: 100,
      stage: 1, kills: 0, bossKills: 0, eliteKills: 0,
      enemies: [], items: [], powerups: [], projectiles: [], walls: [], traps: [], weaponDrops: [],
      combo: 0, comboTimer: null, dashCooldown: 0, specialCooldown: 0,
      score: 0, surviveSec: 0, timeAcc: 0, scorePerSecBase: 5, gold: 0,
      nick: 'Guest',
      character: 'basic',
      unlocks: { basic: true, assassin: false, paladin: false },
      achievements: {},
      upgrades: { atk: 0, hp: 0, spd: 0 },
      customization: { color: 'red', weapon: 'normal', effect: 'normal' },
      audio: { bgmVol: 0.5, sfxVol: 0.7 },
      weapons: {},
      skills: {},
      pendingSkillChoice: false,
      shieldActive: false,
      invincible: false,
      invincibleTimer: 0,
      regenTimer: 0
    };

    let audioCtx = null;
    let bgmAudio = null;

    // =========================
    // ì˜¤ë””ì˜¤ ì‹œìŠ¤í…œ
    // =========================
    function initAudio() {
      try {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      } catch (e) { console.warn('Web Audio API not supported'); }
      
      // BGM ì˜¤ë””ì˜¤ ìƒì„±
      bgmAudio = new Audio();
      bgmAudio.src = './bgm.wav';
      bgmAudio.loop = true;
      bgmAudio.volume = 0.9;
    }

    function setBgmVolume(v) {
      state.audio.bgmVol = v;
      if (bgmAudio) bgmAudio.volume = v;
    }

    function setSfxVolume(v) { state.audio.sfxVol = v; }

    function playBgm() {
      if (bgmAudio) {
        bgmAudio.currentTime = 0;
        bgmAudio.volume = state.audio.bgmVol;
        bgmAudio.play().catch(e => console.log('BGM play failed:', e));
      }
    }

    function stopBgm() {
      if (bgmAudio) {
        bgmAudio.pause();
        bgmAudio.currentTime = 0;
      }
    }

    function pauseBgm() {
      if (bgmAudio) {
        bgmAudio.pause();
      }
    }

    function resumeBgm() {
      if (bgmAudio) {
        bgmAudio.volume = state.audio.bgmVol;
        bgmAudio.play().catch(e => console.log('BGM resume failed:', e));
      }
    }


    function playSfx(type) {
      if (!audioCtx || state.audio.sfxVol <= 0) return;
      try {
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.connect(gain); gain.connect(audioCtx.destination);

        const now = audioCtx.currentTime;

        switch (type) {
          case 'sfxHit':
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(600, now);
            osc.frequency.exponentialRampToValueAtTime(200, now + 0.1);
            gain.gain.setValueAtTime(state.audio.sfxVol * 0.3, now);
            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
            osc.start(now);
            osc.stop(now + 0.1);
            break;

          case 'sfxPick':
            osc.type = 'sine';
            osc.frequency.setValueAtTime(800, now);
            osc.frequency.exponentialRampToValueAtTime(1200, now + 0.15);
            gain.gain.setValueAtTime(state.audio.sfxVol * 0.25, now);
            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
            osc.start(now);
            osc.stop(now + 0.15);
            break;

          case 'sfxDamage':
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(150, now);
            osc.frequency.exponentialRampToValueAtTime(80, now + 0.2);
            gain.gain.setValueAtTime(state.audio.sfxVol * 0.35, now);
            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
            osc.start(now);
            osc.stop(now + 0.2);
            break;

          case 'sfxLevelUp':
            osc.type = 'sine';
            osc.frequency.setValueAtTime(523, now);
            osc.frequency.setValueAtTime(659, now + 0.1);
            osc.frequency.setValueAtTime(784, now + 0.2);
            gain.gain.setValueAtTime(state.audio.sfxVol * 0.3, now);
            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.4);
            osc.start(now);
            osc.stop(now + 0.4);
            break;

          case 'sfxLose':
            osc.type = 'triangle';
            osc.frequency.setValueAtTime(400, now);
            osc.frequency.exponentialRampToValueAtTime(100, now + 0.5);
            gain.gain.setValueAtTime(state.audio.sfxVol * 0.4, now);
            gain.gain.linearRampToValueAtTime(0.01, now + 0.5);
            osc.start(now);
            osc.stop(now + 0.5);
            break;

          case 'sfxBtn':
            osc.type = 'square';
            osc.frequency.value = 400;
            gain.gain.setValueAtTime(state.audio.sfxVol * 0.2, now);
            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.08);
            osc.start(now);
            osc.stop(now + 0.08);
            break;

          case 'sfxBuy':
            osc.type = 'sine';
            osc.frequency.setValueAtTime(600, now);
            osc.frequency.setValueAtTime(800, now + 0.08);
            gain.gain.setValueAtTime(state.audio.sfxVol * 0.25, now);
            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
            osc.start(now);
            osc.stop(now + 0.15);
            break;

          case 'sfxError':
            osc.type = 'sawtooth';
            osc.frequency.value = 150;
            gain.gain.setValueAtTime(state.audio.sfxVol * 0.3, now);
            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
            osc.start(now);
            osc.stop(now + 0.15);
            break;

          default:
            osc.frequency.value = 440;
            gain.gain.setValueAtTime(state.audio.sfxVol * 0.25, now);
            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.12);
            osc.start(now);
            osc.stop(now + 0.12);
        }
      } catch (e) { console.warn('SFX failed:', e); }
    }
    

    // =========================
    // ì €ì¥/ë¡œë“œ ì‹œìŠ¤í…œ
    // =========================
    function loadSave() {
      const s = JSON.parse(localStorage.getItem(LS_KEYS.save) || '{}');
      if (s.nick) state.nick = s.nick;
      if (s.gold != null) state.gold = s.gold;
      if (s.unlocks) state.unlocks = Object.assign(state.unlocks, s.unlocks);
      if (s.achievements) state.achievements = Object.assign({}, s.achievements);
      if (s.upgrades) state.upgrades = Object.assign(state.upgrades, s.upgrades);
      if (s.customization) state.customization = Object.assign(state.customization, s.customization);
      if (s.character && state.unlocks[s.character]) state.character = s.character;
      UI.nickLabel.textContent = state.nick;
      UI.gold.textContent = state.gold;
      const st = loadSettings();
      INPUTS.bgmVol.value = st.bgmVol ?? 0.5;
      INPUTS.sfxVol.value = st.sfxVol ?? 0.7;
      setBgmVolume(INPUTS.bgmVol.value);
      setSfxVolume(INPUTS.sfxVol.value);
    }

    function saveMeta() {
      localStorage.setItem(LS_KEYS.save, JSON.stringify({
        nick: state.nick,
        gold: state.gold,
        unlocks: state.unlocks,
        character: state.character,
        achievements: state.achievements,
        upgrades: state.upgrades,
        customization: state.customization
      }));
    }

    function loadSettings() {
      return JSON.parse(localStorage.getItem(LS_KEYS.settings) || '{}');
    }

    function saveSettings() {
      localStorage.setItem(LS_KEYS.settings, JSON.stringify({
        bgmVol: Number(INPUTS.bgmVol.value),
        sfxVol: Number(INPUTS.sfxVol.value)
      }));
    }

    function addScoreRecord(entry) {
      const list = JSON.parse(localStorage.getItem(LS_KEYS.scores) || '[]');
      list.push(entry);
      list.sort((a, b) => b.score - a.score);
      localStorage.setItem(LS_KEYS.scores, JSON.stringify(list.slice(0, 10)));
    }

    function loadScores() { return JSON.parse(localStorage.getItem(LS_KEYS.scores) || '[]'); }

    // =========================
    // UI ì—…ë°ì´íŠ¸
    // =========================
    function updateUI() {
      updateUIField(UI.hpText, `${Math.floor(state.hp)}/${state.maxHp}`);
      UI.hpFill.style.width = (state.hp / state.maxHp * 100) + '%';
      updateUIField(UI.level, state.level);
      updateUIField(UI.expText, `${state.exp}/${state.maxExp}`);
      UI.expFill.style.width = (state.exp / state.maxExp * 100) + '%';
      updateUIField(UI.stage, state.stage);
      updateUIField(UI.atk, Math.floor(calculateTotalAtk()));
      updateUIField(UI.kills, state.kills);
      updateUIField(UI.score, Math.floor(state.score));
      updateUIField(UI.survive, `${state.surviveSec}s`);
      updateUIField(UI.gold, state.gold);
      updateUIField(UI.expectedGold, scoreToGold(state.score) + 'G');
      if (state.hp <= 0) gameOver();
    }

    function updateUIField(el, val) {
      if (el && el.textContent !== String(val)) el.textContent = String(val);
    }

    function updateWeaponUI() {
      const weaponEntries = Object.entries(state.weapons);
      if (weaponEntries.length === 0) {
        weaponUIEl.innerHTML = '<div style="font-size:12px;font-weight:bold;margin-bottom:8px;text-align:center;color:#ffd700">ë³´ìœ  ë¬´ê¸°</div><div style="font-size:11px;opacity:0.7;text-align:center">ë¬´ê¸° ì—†ìŒ</div>';
        return;
      }

      let html = '<div style="font-size:12px;font-weight:bold;margin-bottom:8px;text-align:center;color:#ffd700">ë³´ìœ  ë¬´ê¸°</div>';
      weaponEntries.forEach(([id, count]) => {
        const weapon = WEAPONS[id];
        if (weapon) {
          html += `
            <div class="weapon-slot">
              <div class="weapon-icon" style="background:${weapon.color}">${weapon.icon}</div>
              <div class="weapon-info">
                <div class="weapon-name">${weapon.name}</div>
                <div class="weapon-stack">x${count} - ${weapon.desc}</div>
              </div>
            </div>
          `;
        }
      });
      weaponUIEl.innerHTML = html;
    }

    function updateSkillsUI() {
      const skillEntries = Object.entries(state.skills);
      if (skillEntries.length === 0) {
        skillsUIEl.innerHTML = '<div style="font-size:12px;font-weight:bold;margin-bottom:8px;text-align:center;color:#ffd700">ë³´ìœ  ìŠ¤í‚¬</div><div style="font-size:11px;opacity:0.7;text-align:center;padding:10px">ìŠ¤í‚¬ ì—†ìŒ</div>';
        return;
      }

      let html = '<div style="font-size:12px;font-weight:bold;margin-bottom:8px;text-align:center;color:#ffd700">ë³´ìœ  ìŠ¤í‚¬</div>';
      skillEntries.forEach(([id, level]) => {
        const skill = SKILLS[id] || FUSION_SKILLS[id];
        if (skill) {
          html += `
            <div class="skill-bar">
              <span>${skill.icon}</span>
              <div class="skill-bar-name">${skill.name}</div>
              <div class="skill-bar-level">Lv${level}</div>
            </div>
          `;
        }
      });
      skillsUIEl.innerHTML = html;
    }

    // =========================
    // ë¬´ê¸° ì‹œìŠ¤í…œ
    // =========================
    function createWeaponDrop(x, y) {
      const weaponKeys = Object.keys(WEAPONS);
      const randomWeapon = WEAPONS[weaponKeys[Math.floor(Math.random() * weaponKeys.length)]];
      
      const el = document.createElement('div');
      el.className = 'weapon-drop';
      el.style.left = x + 'px';
      el.style.top = y + 'px';
      el.style.background = randomWeapon.color;
      el.textContent = randomWeapon.icon;
      game.appendChild(el);
      
      state.weaponDrops.push({ element: el, x, y, weaponId: randomWeapon.id });
    }

    function pickupWeapon(weaponId) {
      if (!state.weapons[weaponId]) {
        state.weapons[weaponId] = 0;
      }
      state.weapons[weaponId]++;
      applyWeaponEffects();
      updateWeaponUI();
      playSfx('sfxPick');
    }

    function applyWeaponEffects() {
      // ë¬´ê¸° íš¨ê³¼ ì¬ê³„ì‚°
      let bonusAtk = 0;
      let bonusSpeed = 0;
      
      Object.entries(state.weapons).forEach(([id, count]) => {
        const weapon = WEAPONS[id];
        if (weapon) {
          if (weapon.effect === 'atk') {
            bonusAtk += weapon.value * count;
          } else if (weapon.effect === 'speed') {
            bonusSpeed += weapon.value * count;
          }
        }
      });
      
      // ê¸°ë³¸ ìŠ¤íƒ¯ì— ë¬´ê¸° ë³´ë„ˆìŠ¤ëŠ” ë³„ë„ë¡œ ì ìš©ë¨ (calculateTotalAtk, calculateTotalSpeedì—ì„œ ì²˜ë¦¬)
    }

    function calculateTotalAtk() {
      let total = state.atk;
      
      // ë¬´ê¸° ë³´ë„ˆìŠ¤
      Object.entries(state.weapons).forEach(([id, count]) => {
        const weapon = WEAPONS[id];
        if (weapon && weapon.effect === 'atk') {
          total += weapon.value * count;
        }
      });
      
      // ìŠ¤í‚¬ ë³´ë„ˆìŠ¤
      if (state.skills.powerBoost) {
        total += SKILLS.powerBoost.getValue(state.skills.powerBoost);
      }
      if (state.skills.berserker) {
        total += FUSION_SKILLS.berserker.getValue(state.skills.berserker);
      }
      
      // ë¶„ë…¸ ìŠ¤í‚¬
      if (state.skills.rage && state.hp < state.maxHp * 0.5) {
        total *= (1 + SKILLS.rage.getValue(state.skills.rage) / 100);
      }
      
      return total;
    }

    function calculateTotalSpeed() {
      let total = state.speed;
      
      // ë¬´ê¸° ë³´ë„ˆìŠ¤
      Object.entries(state.weapons).forEach(([id, count]) => {
        const weapon = WEAPONS[id];
        if (weapon && weapon.effect === 'speed') {
          total += weapon.value * count;
        }
      });
      
      // ìŠ¤í‚¬ ë³´ë„ˆìŠ¤
      if (state.skills.speedBoost) {
        total += SKILLS.speedBoost.getValue(state.skills.speedBoost);
      }
      if (state.skills.fortress) {
        total += FUSION_SKILLS.fortress.getValue(state.skills.fortress) * 0.015;
      }
      
      return total;
    }

    // =========================
    // ìŠ¤í‚¬ ì‹œìŠ¤í…œ
    // =========================
    function showSkillDialog() {
      if (state.pendingSkillChoice) return;
      
      state.pendingSkillChoice = true;
      state.running = false;
      
      const availableSkills = getAvailableSkills();
      const choices = selectRandomSkills(availableSkills, 3);
      
      LISTS.skillChoices.innerHTML = '';
      
      choices.forEach(skillId => {
        const isFusion = FUSION_SKILLS[skillId];
        const skill = isFusion ? FUSION_SKILLS[skillId] : SKILLS[skillId];
        const currentLevel = state.skills[skillId] || 0;
        
        const div = document.createElement('div');
        div.className = 'skill-choice' + (isFusion ? ' skill-fusion' : '');
        div.innerHTML = `
          <div class="skill-name">${skill.icon} ${skill.name}</div>
          <div class="skill-level">í˜„ì¬ ë ˆë²¨: ${currentLevel} â†’ ${currentLevel + 1}</div>
          <div class="skill-desc">${skill.desc(currentLevel + 1)}</div>
          ${isFusion ? '<div style="margin-top:8px;font-size:12px;color:#d946ef">â­ ìœµí•© ìŠ¤í‚¬ â­</div>' : ''}
        `;
        
        div.onclick = () => {
          selectSkill(skillId);
        };
        
        LISTS.skillChoices.appendChild(div);
      });
      
      MODALS.skillDialog.style.display = 'block';
    }

    function getAvailableSkills() {
      const available = [];
      
      // ì¼ë°˜ ìŠ¤í‚¬
      Object.keys(SKILLS).forEach(id => {
        const currentLevel = state.skills[id] || 0;
        if (currentLevel < SKILLS[id].maxLevel) {
          available.push(id);
        }
      });
      
      // ìœµí•© ìŠ¤í‚¬ ì²´í¬
      Object.keys(FUSION_SKILLS).forEach(id => {
        const fusion = FUSION_SKILLS[id];
        const currentLevel = state.skills[id] || 0;
        
        if (currentLevel < fusion.maxLevel) {
          const hasRequirements = fusion.requires.every(reqId => {
            return (state.skills[reqId] || 0) >= fusion.requiredLevel;
          });
          
          if (hasRequirements) {
            available.push(id);
          }
        }
      });
      
      return available;
    }

    function selectRandomSkills(available, count) {
      const shuffled = [...available].sort(() => Math.random() - 0.5);
      return shuffled.slice(0, Math.min(count, shuffled.length));
    }

    function selectSkill(skillId) {
      if (!state.skills[skillId]) {
        state.skills[skillId] = 0;
      }
      state.skills[skillId]++;
      
      applySkillEffects(skillId);
      updateSkillsUI();
      
      MODALS.skillDialog.style.display = 'none';
      state.pendingSkillChoice = false;
      state.running = true;
      
      playSfx('sfxLevelUp');
    }

    function applySkillEffects(skillId) {
      const skill = SKILLS[skillId] || FUSION_SKILLS[skillId];
      if (!skill) return;
      
      // ë°©ì–´ë§‰ ìŠ¤í‚¬ - ìµœëŒ€ ì²´ë ¥ ì¦ê°€
      if (skillId === 'shield') {
        const hpBonus = skill.getValue(state.skills[skillId]);
        state.maxHp = getChar().baseHp + state.upgrades.hp * UPGRADE_DEFS.hp.perLevel + hpBonus;
        if (state.skills.fortress) {
          state.maxHp += FUSION_SKILLS.fortress.getValue(state.skills.fortress);
        }
        state.hp = Math.min(state.hp + hpBonus, state.maxHp);
        updateShieldVisual();
      }
      
      // ìš”ìƒˆ ìœµí•© ìŠ¤í‚¬
      if (skillId === 'fortress') {
        const hpBonus = FUSION_SKILLS.fortress.getValue(state.skills.fortress);
        state.maxHp += hpBonus;
        state.hp = Math.min(state.hp + hpBonus, state.maxHp);
        updateShieldVisual();
      }
      
      updateUI();
    }

    function updateShieldVisual() {
      const hasShield = state.skills.shield || state.skills.fortress;
      const existing = playerEl.querySelector('.shield-visual');
      
      if (hasShield && !existing) {
        const shield = document.createElement('div');
        shield.className = 'shield-visual';
        playerEl.appendChild(shield);
      } else if (!hasShield && existing) {
        existing.remove();
      }
    }

    // =========================
    // ê²½í—˜ì¹˜ ë° ë ˆë²¨ì—…
    // =========================
    function gainExp(amount) {
      state.exp += amount;
      if (state.exp >= state.maxExp) {
        state.exp -= state.maxExp;
        state.level++;
        state.maxExp = Math.floor(state.maxExp * 1.5);
        
        showDamage(state.playerX, state.playerY - 30, 'LEVEL UP!', true);
        playSfx('sfxLevelUp');
        
        // ìŠ¤í‚¬ ì„ íƒ ë‹¤ì´ì–¼ë¡œê·¸ í‘œì‹œ
        showSkillDialog();
      }
      updateUI();
    }

    // =========================
    // íŒŒí‹°í´ ë° ì‹œê° íš¨ê³¼
    // =========================
    function showWaveWarning() {
      MODALS.waveWarning.style.display = 'block';
      setTimeout(() => MODALS.waveWarning.style.display = 'none', 1200);
    }

    function showCombo() {
      const old = document.getElementById('combo'); if (old) old.remove();
      if (state.combo > 1) {
        const el = document.createElement('div'); el.id = 'combo'; el.textContent = `${state.combo} COMBO!`;
        game.appendChild(el);
        setTimeout(() => el.remove(), 500);
      }
    }

    function createParticles(x, y, color = '#ff006e') {
      if (document.querySelectorAll('.particle').length > 60) return;
      for (let i = 0; i < 10; i++) {
        const p = document.createElement('div'); p.className = 'particle';
        p.style.left = x + 'px'; p.style.top = y + 'px'; p.style.background = color;
        const ang = (Math.PI * 2 * i) / 10, dist = 30 + Math.random() * 20;
        p.style.setProperty('--x', Math.cos(ang) * dist + 'px');
        p.style.setProperty('--y', Math.sin(ang) * dist + 'px');
        game.appendChild(p); setTimeout(() => p.remove(), 800);
      }
    }

    function showDamage(x, y, text, isHeal = false) {
      if (document.querySelectorAll('.damage').length > 35) return;
      const d = document.createElement('div');
      d.className = 'damage' + (isHeal ? ' heal' : '');
      d.textContent = (isHeal ? '+' : '-') + text;
      d.style.left = x + 'px'; d.style.top = y + 'px';
      game.appendChild(d); setTimeout(() => d.remove(), 1000);
    }

    function updateMinimap() {
      const dots = ['<div class="minimapDot playerDot" style="left:' + (state.playerX / 800 * 150) + 'px;top:' + (state.playerY / 500 * 100) + 'px"></div>'];
      for (const e of state.enemies) {
        const cls = e.isBoss ? 'bossDot' : e.isElite ? 'eliteDot' : 'enemyDot';
        dots.push('<div class="minimapDot ' + cls + '" style="left:' + (e.x / 800 * 150) + 'px;top:' + (e.y / 500 * 100) + 'px"></div>');
      }
      minimap.innerHTML = dots.join('');
    }

    // =========================
    // ë§µ ìš”ì†Œ ìƒì„±
    // =========================
    function createWall(x, y, w, h) {
      const el = document.createElement('div');
      el.className = 'wall';
      el.style.left = x + 'px';
      el.style.top = y + 'px';
      el.style.width = w + 'px';
      el.style.height = h + 'px';
      game.appendChild(el);
      state.walls.push({ element: el, x, y, w, h });
    }

    function createTrap(x, y) {
      const el = document.createElement('div');
      el.className = 'trap';
      el.style.left = x + 'px';
      el.style.top = y + 'px';
      el.style.width = '30px';
      el.style.height = '30px';
      game.appendChild(el);
      state.traps.push({ element: el, x, y, lastDamage: 0 });
    }

    function generateMapElements() {
      const wallCount = 2 + Math.floor(state.stage / 2);
      const playerSafeZone = 150;

      for (let i = 0; i < wallCount; i++) {
        let x, y, w, h;
        let attempts = 0;
        const maxAttempts = 50;

        do {
          x = 50 + Math.random() * 650;
          y = 50 + Math.random() * 400;
          w = 60 + Math.random() * 80;
          h = 40 + Math.random() * 60;
          attempts++;

          const distToPlayer = Math.hypot(
            (x + w / 2) - (state.playerX + 20),
            (y + h / 2) - (state.playerY + 20)
          );

          let overlapsWall = false;
          for (const wall of state.walls) {
            if (x < wall.x + wall.w + 20 && x + w + 20 > wall.x &&
              y < wall.y + wall.h + 20 && y + h + 20 > wall.y) {
              overlapsWall = true;
              break;
            }
          }

          if (distToPlayer >= playerSafeZone && !overlapsWall) break;

        } while (attempts < maxAttempts);

        if (attempts < maxAttempts) {
          createWall(x, y, w, h);
        }
      }

      if (state.stage >= 3) {
        const trapCount = 1 + Math.floor(state.stage / 3);
        for (let i = 0; i < trapCount; i++) {
          let x, y;
          let attempts = 0;
          const maxAttempts = 50;

          do {
            x = 50 + Math.random() * 700;
            y = 50 + Math.random() * 420;
            attempts++;

            const distToPlayer = Math.hypot(x - state.playerX, y - state.playerY);
            const onWall = checkWallCollision(x, y, 30);

            let tooClose = false;
            for (const trap of state.traps) {
              if (Math.hypot(x - trap.x, y - trap.y) < 80) {
                tooClose = true;
                break;
              }
            }

            if (distToPlayer >= playerSafeZone && !onWall && !tooClose) break;

          } while (attempts < maxAttempts);

          if (attempts < maxAttempts) {
            createTrap(x, y);
          }
        }
      }
      
      // ë¬´ê¸° ë“œë¡­ ìƒì„±
      if (Math.random() < 0.5) {
        let x = 100 + Math.random() * 600;
        let y = 100 + Math.random() * 300;
        createWeaponDrop(x, y);
      }
    }

    function checkWallCollision(x, y, size = 40) {
      for (const w of state.walls) {
        if (x < w.x + w.w && x + size > w.x && y < w.y + w.h && y + size > w.y) return true;
      }
      return false;
    }

    function checkWallCollisionRect(x, y, w, h) {
      for (const wall of state.walls) {
        if (x < wall.x + wall.w && x + w > wall.x && y < wall.y + wall.h && y + h > wall.y) return wall;
      }
      return null;
    }

    function getAvoidanceVector(x, y, size) {
      const wall = checkWallCollisionRect(x, y, size, size);
      if (!wall) return { x: 0, y: 0 };

      const centerX = x + size / 2;
      const centerY = y + size / 2;
      const wallCenterX = wall.x + wall.w / 2;
      const wallCenterY = wall.y + wall.h / 2;

      const dx = centerX - wallCenterX;
      const dy = centerY - wallCenterY;
      const dist = Math.hypot(dx, dy) || 1;

      return { x: dx / dist, y: dy / dist };
    }

    function checkTrapCollision() {
      const now = Date.now();
      for (const t of state.traps) {
        const d = Math.hypot(state.playerX - t.x, state.playerY - t.y);
        if (d < 35 && now - t.lastDamage > 1000) {
          if (!state.invincible) {
            state.hp -= 10;
            t.lastDamage = now;
            showDamage(state.playerX, state.playerY, 10);
            playSfx('sfxDamage');
            playerEl.classList.add('flash');
            setTimeout(() => playerEl.classList.remove('flash'), 600);
            updateUI();
          }
        }
      }
    }

    // =========================
    // ì  ìƒì„± ë° ê´€ë¦¬
    // =========================
    function createEnemy(type = 'normal') {
      const el = document.createElement('div');
      const isBoss = type === 'boss';
      const isElite = type === 'elite';

      el.className = isBoss ? 'enemy boss' : isElite ? 'enemy elite' : 'enemy';

      let x, y;
      const size = isBoss ? 60 : isElite ? 45 : 35;
      let attempts = 0;
      const maxAttempts = 100;

      do {
        x = Math.random() * (800 - size);
        y = Math.random() * (500 - size);
        attempts++;

        const distToPlayer = Math.hypot(x - state.playerX, y - state.playerY);

        if (distToPlayer >= 100 && !checkWallCollision(x, y, size)) {
          break;
        }
      } while (attempts < maxAttempts);

      if (attempts >= maxAttempts) {
        x = Math.random() < 0.5 ? 10 : 800 - size - 10;
        y = Math.random() * (500 - size);
      }

      el.style.left = x + 'px'; el.style.top = y + 'px';

      const bar = document.createElement('div'); bar.className = 'enemyHpBar';
      const fill = document.createElement('div'); fill.className = 'enemyHpFill';
      bar.appendChild(fill); el.appendChild(bar);
      game.appendChild(el);

      let hp, speed;
      if (isBoss) {
        hp = 200 + state.stage * 50;
        speed = 0.6;
      } else if (isElite) {
        hp = 100 + state.stage * 20;
        speed = 1.2;
      } else {
        hp = 30 + state.stage * 10;
        speed = 1;
      }

      const data = {
        element: el, hpFill: fill, x, y,
        hp, maxHp: hp, speed,
        isBoss, isElite,
        lastDamageTime: 0
      };
      state.enemies.push(data);
    }

    function createItem(x, y, type = 'heal') {
      const el = document.createElement('div');
      el.className = (type === 'powerup') ? 'powerup' : 'item';
      el.style.left = x + 'px'; el.style.top = y + 'px';
      game.appendChild(el);
      if (type === 'powerup') state.powerups.push({ element: el, x, y });
      else state.items.push({ element: el, x, y, type });
    }

    function createProjectile(x, y, dx, dy) {
      const el = document.createElement('div');
      el.className = 'projectile';
      const weaponStyle = state.customization.weapon;
      const weaponColor = CUSTOMIZATION.weapons.find(w => w.id === weaponStyle)?.color || '#06ffa5';
      el.style.background = `radial-gradient(circle, ${weaponColor}, #3a86ff)`;
      el.style.left = x + 'px'; el.style.top = y + 'px';
      game.appendChild(el);
      
      const penetration = state.skills.penetration ? SKILLS.penetration.getValue(state.skills.penetration) : 0;
      const destroyerBonus = state.skills.destroyer ? 5 : 0;
      
      state.projectiles.push({ 
        element: el, x, y, dx, dy, 
        damage: calculateTotalAtk(),
        penetration: penetration + destroyerBonus,
        hitCount: 0
      });
    }

    // =========================
    // ì „íˆ¬ ì‹œìŠ¤í…œ
    // =========================
    function attack() {
      if (state.specialCooldown > 0) return;
      const n = nearestEnemy(); if (!n || n.dist >= 400) return;
      const dx = (n.enemy.x - state.playerX) / n.dist * 10;
      const dy = (n.enemy.y - state.playerY) / n.dist * 10;
      createProjectile(state.playerX + 15, state.playerY + 15, dx, dy);
      playSfx('sfxHit');
    }

    function specialAttack() {
      if (state.specialCooldown > 0) return;
      state.specialCooldown = 30;
      const ch = getChar(); 
      let count = ch.projCount || 8;
      
      // ë‹¤ì¤‘ ë°œì‚¬ ìŠ¤í‚¬
      if (state.skills.multiShot) {
        count += SKILLS.multiShot.getValue(state.skills.multiShot);
      }
      
      for (let i = 0; i < count; i++) {
        const ang = (Math.PI * 2 * i) / count;
        createProjectile(state.playerX + 15, state.playerY + 15, Math.cos(ang) * 8, Math.sin(ang) * 8);
      }
      playSfx('sfxHit');
    }

    function dash() {
      if (state.dashCooldown > 0) return;
      state.dashCooldown = 20;
      let dx = 0, dy = 0;
      if (state.keys['ArrowLeft']) dx -= 1;
      if (state.keys['ArrowRight']) dx += 1;
      if (state.keys['ArrowUp']) dy -= 1;
      if (state.keys['ArrowDown']) dy += 1;
      if (dx || dy) {
        const d = Math.hypot(dx, dy);
        const ch = getChar();
        let newX = state.playerX + (dx / d) * 100;
        let newY = state.playerY + (dy / d) * 100;

        if (checkWallCollision(newX, newY, ch.size)) {
          newX = state.playerX + (dx / d) * 50;
          newY = state.playerY + (dy / d) * 50;

          if (checkWallCollision(newX, newY, ch.size)) {
            return;
          }
        }

        state.playerX = newX;
        state.playerY = newY;
        clampPlayer();
      }
    }

    function nearestEnemy() {
      return state.enemies.reduce((n, e) => {
        const d = Math.hypot(state.playerX - e.x, state.playerY - e.y);
        if (!n || d < n.dist) return { enemy: e, dist: d };
        return n;
      }, null);
    }

    function clampPlayer() {
      const ch = getChar();
      state.playerX = Math.max(0, Math.min(800 - ch.size, state.playerX));
      state.playerY = Math.max(0, Math.min(500 - ch.size, state.playerY));
      playerEl.style.left = state.playerX + 'px';
      playerEl.style.top = state.playerY + 'px';
    }

    async function nextStage() {
      if (state.enemies.length === 0 && state.running) {
        for (const arr of [state.walls, state.traps]) {
          arr.forEach(o => o.element?.remove()); arr.length = 0;
        }

        state.stage++; updateUI(); showWaveWarning();

        generateMapElements();

        const cnt = 2 + state.stage;
        for (let i = 0; i < cnt; i++) { createEnemy('normal'); await delay(150); }

        if (state.stage % 3 === 0) { await delay(200); createEnemy('elite'); }
        if (state.stage % 5 === 0) { await delay(300); createEnemy('boss'); }

        if (Math.random() < 0.4) createItem(Math.random() * 770, Math.random() * 470, 'powerup');
      }
    }

    const delay = (ms) => new Promise(r => setTimeout(r, ms));

    // =========================
    // ê²Œì„ ë£¨í”„ ì—…ë°ì´íŠ¸
    // =========================
    function stepProjectiles() {
      for (let i = state.projectiles.length - 1; i >= 0; i--) {
        const p = state.projectiles[i];
        p.x += p.dx; p.y += p.dy;
        p.element.style.left = p.x + 'px'; p.element.style.top = p.y + 'px';

        let hitWall = false;
        for (const w of state.walls) {
          if (p.x >= w.x && p.x <= w.x + w.w && p.y >= w.y && p.y <= w.y + w.h) {
            hitWall = true; break;
          }
        }

        if (p.x < 0 || p.x > 800 || p.y < 0 || p.y > 500 || hitWall) {
          p.element.remove(); state.projectiles.splice(i, 1); continue;
        }

        for (let j = state.enemies.length - 1; j >= 0; j--) {
          const e = state.enemies[j];
          const d = Math.hypot(p.x - (e.x + 17), p.y - (e.y + 17));
          if (d < 30) {
            let damage = p.damage;
            
            // ì¹˜ëª…íƒ€ ì²´í¬
            if (state.skills.criticalHit) {
              const critChance = SKILLS.criticalHit.getValue(state.skills.criticalHit);
              if (Math.random() * 100 < critChance) {
                damage *= 2;
                showDamage(e.x + 17, e.y, 'CRIT!', false);
              }
            }
            
            // íŒŒê´´ì ìœµí•© ìŠ¤í‚¬
            if (state.skills.destroyer) {
              const critChance = FUSION_SKILLS.destroyer.getValue(state.skills.destroyer);
              if (Math.random() * 100 < critChance) {
                damage *= 3;
                showDamage(e.x + 17, e.y, 'MEGA CRIT!', false);
              }
            }
            
            e.hp -= damage;
            e.hpFill.style.width = (e.hp / e.maxHp * 100) + '%';
            showDamage(e.x + 17, e.y, Math.floor(damage));
            
            // ê´€í†µ ì²´í¬
            p.hitCount++;
            if (p.hitCount > p.penetration) {
              p.element.remove(); 
              state.projectiles.splice(i, 1);
            }
            
            if (e.hp <= 0) {
              handleEnemyKill(e, j);
            }
            break;
          }
        }
      }
    }

    function handleEnemyKill(e, index) {
      state.combo++; 
      resetComboTimer(); 
      showCombo();
      
      if (e.isBoss) state.bossKills++;
      if (e.isElite) state.eliteKills++;
      
      const color = e.isBoss ? '#d946ef' : e.isElite ? '#ffa500' : '#ff4d4d';
      createParticles(e.x + 17, e.y + 17, color);
      
      e.element.remove(); 
      state.enemies.splice(index, 1);
      state.kills++;
      
      const scoreAdd = (e.isBoss ? 100 : e.isElite ? 50 : 10) * Math.max(1, state.combo);
      state.score += scoreAdd;
      gainExp(e.isBoss ? 50 : e.isElite ? 30 : 10);
      
      // í¡í˜ˆ ìŠ¤í‚¬
      if (state.skills.lifeSteal) {
        const healAmount = SKILLS.lifeSteal.getValue(state.skills.lifeSteal);
        state.hp = Math.min(state.maxHp, state.hp + healAmount);
        showDamage(state.playerX, state.playerY, healAmount, true);
      }
      
      // ê´‘ì „ì‚¬ ìœµí•© ìŠ¤í‚¬
      if (state.skills.berserker) {
        const healAmount = FUSION_SKILLS.berserker.getValue(state.skills.berserker) * 0.5;
        state.hp = Math.min(state.maxHp, state.hp + healAmount);
        showDamage(state.playerX, state.playerY, Math.floor(healAmount), true);
      }
      
      if (Math.random() < 0.3) createItem(e.x, e.y, 'heal');
      if (Math.random() < 0.15) createWeaponDrop(e.x, e.y);
      
      checkAchievements();
      updateUI();
    }

    function stepEnemies() {
      const now = Date.now();
      const heavy = state.enemies.length >= 40;
      for (const e of state.enemies) {
        if (heavy) e.element.style.animation = 'none';
        const dx = state.playerX - e.x, dy = state.playerY - e.y;
        const d = Math.hypot(dx, dy) || 1;

        let moveX = (dx / d) * e.speed;
        let moveY = (dy / d) * e.speed;

        const size = e.isBoss ? 60 : e.isElite ? 45 : 35;
        const testX = e.x + moveX;
        const testY = e.y + moveY;

        if (checkWallCollision(testX, testY, size)) {
          const avoid = getAvoidanceVector(testX, testY, size);

          const altMoveX1 = moveY * 0.7 + avoid.x * e.speed * 0.5;
          const altMoveY1 = -moveX * 0.7 + avoid.y * e.speed * 0.5;

          if (!checkWallCollision(e.x + altMoveX1, e.y + altMoveY1, size)) {
            moveX = altMoveX1;
            moveY = altMoveY1;
          } else {
            const altMoveX2 = -moveY * 0.7 + avoid.x * e.speed * 0.5;
            const altMoveY2 = moveX * 0.7 + avoid.y * e.speed * 0.5;

            if (!checkWallCollision(e.x + altMoveX2, e.y + altMoveY2, size)) {
              moveX = altMoveX2;
              moveY = altMoveY2;
            } else {
              moveX = avoid.x * e.speed;
              moveY = avoid.y * e.speed;
            }
          }
        }

        e.x += moveX;
        e.y += moveY;

        e.element.style.left = e.x + 'px'; e.element.style.top = e.y + 'px';
        
        if (d < 40 && now - e.lastDamageTime > 500) {
          if (!state.invincible) {
            const dmg = e.isBoss ? 10 : e.isElite ? 8 : 5;
            state.hp -= dmg;
            e.lastDamageTime = now;
            showDamage(state.playerX, state.playerY, dmg);
            playSfx('sfxDamage');
            playerEl.classList.add('flash');
            setTimeout(() => playerEl.classList.remove('flash'), 600);
            
            // ìš”ìƒˆ ìŠ¤í‚¬ - í”¼ê²© ì‹œ ë¬´ì 
            if (state.skills.fortress && !state.invincible) {
              state.invincible = true;
              state.invincibleTimer = 3;
              showDamage(state.playerX, state.playerY - 40, 'INVINCIBLE!', true);
            }
            
            updateUI();
          }
        }
      }
    }

    function stepPickups() {
      for (let i = state.items.length - 1; i >= 0; i--) {
        const it = state.items[i];
        const d = Math.hypot(state.playerX - it.x, state.playerY - it.y);
        if (d < 40) {
          state.hp = Math.min(state.maxHp, state.hp + 30);
          showDamage(state.playerX, state.playerY, 30, true);
          createParticles(it.x, it.y, '#ffd700');
          it.element.remove(); state.items.splice(i, 1);
          updateUI(); playSfx('sfxPick');
        }
      }
      
      for (let i = state.powerups.length - 1; i >= 0; i--) {
        const it = state.powerups[i];
        const d = Math.hypot(state.playerX - it.x, state.playerY - it.y);
        if (d < 40) {
          state.atk += 10;
          showDamage(state.playerX, state.playerY, 'ATK +10!', true);
          createParticles(it.x, it.y, '#06ffa5');
          it.element.remove(); state.powerups.splice(i, 1);
          updateUI(); playSfx('sfxPick');
        }
      }
      
      for (let i = state.weaponDrops.length - 1; i >= 0; i--) {
        const it = state.weaponDrops[i];
        const d = Math.hypot(state.playerX - it.x, state.playerY - it.y);
        if (d < 40) {
          pickupWeapon(it.weaponId);
          const weapon = WEAPONS[it.weaponId];
          showDamage(state.playerX, state.playerY, `${weapon.icon} ${weapon.name}!`, true);
          createParticles(it.x, it.y, weapon.color);
          it.element.remove(); 
          state.weaponDrops.splice(i, 1);
        }
      }
    }

    function resetComboTimer() {
      clearTimeout(state.comboTimer);
      state.comboTimer = setTimeout(() => {
        state.combo = 0; const c = document.getElementById('combo'); if (c) c.remove();
      }, 2000);
    }

    function stepTimerAndScore(dt) {
      state.timeAcc += dt;
      const prev = state.surviveSec;
      while (state.timeAcc >= 1) {
        state.timeAcc -= 1;
        state.surviveSec += 1;
        state.score += state.scorePerSecBase * Math.pow(1.05, state.stage);
        
        // ì¡°í™” ìŠ¤í‚¬ - ì²´ë ¥ ì¬ìƒ
        if (state.skills.harmony) {
          state.regenTimer += 1;
          if (state.regenTimer >= 1) {
            const regenAmount = SKILLS.harmony.getValue(state.skills.harmony);
            state.hp = Math.min(state.maxHp, state.hp + regenAmount);
            state.regenTimer = 0;
          }
        }
        
        // ë¬´ì  íƒ€ì´ë¨¸
        if (state.invincible) {
          state.invincibleTimer -= 1;
          if (state.invincibleTimer <= 0) {
            state.invincible = false;
            showDamage(state.playerX, state.playerY - 40, 'SHIELD END', false);
          }
        }
      }
      if (state.surviveSec !== prev) updateUI();
    }

    let lastTs = performance.now();
    function gameLoop(ts) {
      if (state.screen !== 'playing' || !state.running) { lastTs = ts; requestAnimationFrame(gameLoop); return; }
      const dt = Math.min(0.05, (ts - lastTs) / 1000); lastTs = ts;

      let mx = 0, my = 0;
      const sp = calculateTotalSpeed();
      if (state.keys['ArrowLeft']) mx -= sp;
      if (state.keys['ArrowRight']) mx += sp;
      if (state.keys['ArrowUp']) my -= sp;
      if (state.keys['ArrowDown']) my += sp;
      if (mx || my) {
        const d = Math.hypot(mx, my);
        const normalizedX = mx / d * sp;
        const normalizedY = my / d * sp;
        let newX = state.playerX + normalizedX;
        let newY = state.playerY + normalizedY;

        const ch = getChar();

        if (checkWallCollision(newX, newY, ch.size)) {
          if (!checkWallCollision(newX, state.playerY, ch.size)) {
            newY = state.playerY;
          }
          else if (!checkWallCollision(state.playerX, newY, ch.size)) {
            newX = state.playerX;
          }
          else {
            newX = state.playerX;
            newY = state.playerY;
          }
        }

        state.playerX = newX;
        state.playerY = newY;
        clampPlayer();
      }

      stepProjectiles();
      stepEnemies();
      stepPickups();
      checkTrapCollision();

      if (state.dashCooldown > 0) state.dashCooldown--;
      if (state.specialCooldown > 0) state.specialCooldown--;

      updateMinimap();
      nextStage();
      stepTimerAndScore(dt);

      requestAnimationFrame(gameLoop);
    }

    // =========================
    // ì…ë ¥ ì²˜ë¦¬
    // =========================
    document.addEventListener('keydown', e => {
      state.keys[e.key] = true;
      if (state.screen === 'playing') {
        if (e.key === ' ') { attack(); e.preventDefault(); }
        else if (e.key === 'a' || e.key === 'A') { specialAttack(); e.preventDefault(); }
        else if (e.key === 's' || e.key === 'S') { dash(); e.preventDefault(); }
        else if (e.key === 'p' || e.key === 'P') { pauseGame(); e.preventDefault(); }
        else if (e.key === 'Escape') { pauseGame(); e.preventDefault(); }
      } else {
        if (e.key === 'Escape') { goBackFromModal(); }
      }
    });
    document.addEventListener('keyup', e => { state.keys[e.key] = false; });

    // =========================
    // í™”ë©´ ì „í™˜
    // =========================
    function openIntro() {
      state.screen = 'intro';
      showModal('intro');
    }

    function openMenu() {
      state.screen = 'menu'; state.running = false;
      pauseOverlay.style.display = 'none';
      showModal('menu');
      updateCharacterSelect();
    }

    function startGame() {
      applyCharacter();
      state.screen = 'playing'; state.running = true;
      resetRunState();
      hideAllModals();
      pauseOverlay.style.display = 'none';
      updateUI();
      playBgm(); // BGM ì¬ìƒ ì‹œì‘
      requestAnimationFrame(gameLoop);
    }

    function pauseGame() {
      if (state.screen !== 'playing') return;
      state.screen = 'paused'; state.running = false;
      pauseBgm(); // BGM ì¼ì‹œì •ì§€
      pauseOverlay.style.display = 'flex';
      showModal('settings');
      BTN.resumeGame.style.display = 'inline-block';
    }

    function resumeGame() {
      if (state.screen !== 'paused') return;
      state.screen = 'playing'; state.running = true;
      resumeBgm(); // BGM ì¬ê°œ
      hideAllModals();
      pauseOverlay.style.display = 'none';
      BTN.resumeGame.style.display = 'none';
    }

    function goBackFromModal() {
      if (state.screen === 'settings' || state.screen === 'leaderboard' || state.screen === 'shop' || state.screen === 'customize' || state.screen === 'tutorial') {
        openMenu(); return;
      }
      if (state.screen === 'paused') { resumeGame(); return; }
    }

    function showModal(name) {
      hideAllModals();
      MODALS[name].style.display = 'block';
      if (name === 'leaderboard') renderLeaderboard();
      if (name === 'shop') { renderShop(); renderUpgrades(); }
      if (name === 'customize') renderCustomization();
    }

    function hideAllModals() {
      Object.values(MODALS).forEach(m => { if (m) m.style.display = 'none'; });
    }

    function resetRunState() {
      state.playerX = 380; state.playerY = 230;
      const ch = getChar();
      const atkPlus = state.upgrades.atk * UPGRADE_DEFS.atk.perLevel;
      const hpPlus = state.upgrades.hp * UPGRADE_DEFS.hp.perLevel;
      const spdPlus = state.upgrades.spd * UPGRADE_DEFS.spd.perLevel;

      state.maxHp = Math.round(ch.baseHp + hpPlus);
      state.hp = state.maxHp;
      state.atk = Math.round(ch.baseAtk + atkPlus);
      state.speed = (ch.speed + spdPlus);

      state.level = 1; state.exp = 0; state.maxExp = 100;
      state.stage = 1; state.kills = 0; state.bossKills = 0; state.eliteKills = 0;
      state.score = 0; state.surviveSec = 0; state.timeAcc = 0;
      state.combo = 0; clearTimeout(state.comboTimer); const c = document.getElementById('combo'); if (c) c.remove();
      
      state.weapons = {};
      state.skills = {};
      state.pendingSkillChoice = false;
      state.invincible = false;
      state.invincibleTimer = 0;
      state.regenTimer = 0;

      for (const arr of [state.enemies, state.items, state.powerups, state.projectiles, state.walls, state.traps, state.weaponDrops]) {
        arr.forEach(o => o.element?.remove()); arr.length = 0;
      }

      clampPlayer();
      generateMapElements();
      updateWeaponUI();
      updateSkillsUI();
      updateShieldVisual();

      for (let i = 0; i < 3; i++) createEnemy('normal');
      lastTs = performance.now();
    }

    function getChar() { return CHARACTERS[state.character]; }

    function applyCharacter() {
      const ch = getChar();
      playerEl.style.width = ch.size + 'px';
      playerEl.style.height = ch.size + 'px';

      const customColor = CUSTOMIZATION.colors.find(c => c.id === state.customization.color);
      if (customColor) {
        playerEl.style.background = `linear-gradient(135deg, ${customColor.start}, ${customColor.end})`;
      } else {
        playerEl.style.background = `linear-gradient(135deg, ${ch.colorStart}, ${ch.colorEnd})`;
      }

      const effect = state.customization.effect;
      if (effect === 'trail') {
        playerEl.style.boxShadow = `0 0 30px rgba(255,0,110,.8), 0 0 60px rgba(255,0,110,.4)`;
      } else if (effect === 'glow') {
        playerEl.style.boxShadow = `0 0 50px rgba(255,0,110,1)`;
      }
    }

    function updateCharacterSelect() {
      Array.from(INPUTS.char.options).forEach(opt => {
        const id = opt.value;
        if (!state.unlocks[id]) {
          opt.disabled = true;
          opt.textContent = CHARACTERS[id].name + ' (ì ê¹€ - ' + CHARACTERS[id].cost + 'G)';
        } else {
          opt.disabled = false;
          opt.textContent = CHARACTERS[id].name + (CHARACTERS[id].cost > 0 ? ' (í•´ê¸ˆë¨)' : ' (ë¬´ë£Œ)');
        }
      });
    }

    // =========================
    // ìƒì  ë° ì—…ê·¸ë ˆì´ë“œ
    // =========================
    function renderShop() {
      LISTS.shop.innerHTML = '';
      Object.entries(CHARACTERS).forEach(([id, cfg]) => {
        const unlocked = !!state.unlocks[id];
        const card = document.createElement('div');
        card.style.padding = '10px';
        card.style.background = 'rgba(255,255,255,.08)';
        card.style.border = '1px solid rgba(255,255,255,.15)';
        card.style.borderRadius = '12px';
        card.innerHTML = `
      <div class="badge">${cfg.name}</div>
      <div class="badge">HP ${cfg.baseHp}</div>
      <div class="badge">ATK ${cfg.baseAtk}</div>
      <div class="badge">SPD ${cfg.speed}</div>
      <div class="badge">íŠ¹ìˆ˜ê³µê²© ${cfg.projCount}ë°œ</div>
      <div class="badge">${unlocked ? 'âœ… í•´ê¸ˆ ì™„ë£Œ' : `ğŸ”’ ${cfg.cost}G`}</div>
      <div style="margin-top:6px">
        <button class="modal-btn" data-id="${id}" ${!unlocked && state.gold < cfg.cost ? 'disabled' : ''}>${unlocked ? 'ì„ íƒ' : 'í•´ê¸ˆ'}</button>
      </div>
    `;
        LISTS.shop.appendChild(card);
        const btn = card.querySelector('button');
        btn.onclick = () => {
          const idBtn = btn.dataset.id;
          if (state.unlocks[idBtn]) {
            state.character = idBtn; saveMeta(); INPUTS.char.value = idBtn; applyCharacter();
            updateCharacterSelect(); playSfx('sfxBtn');
          } else {
            if (state.gold >= CHARACTERS[idBtn].cost) {
              state.gold -= CHARACTERS[idBtn].cost;
              state.unlocks[idBtn] = true; saveMeta(); updateUI(); renderShop(); updateCharacterSelect(); playSfx('sfxBuy');
            } else {
              playSfx('sfxError'); alert('ê³¨ë“œê°€ ë¶€ì¡±í•©ë‹ˆë‹¤!');
            }
          }
        };
      });
    }

    function calcUpgradeCost(key, level) {
      const def = UPGRADE_DEFS[key];
      return Math.floor(def.costBase * Math.pow(def.costScale, level));
    }

    function renderUpgrades() {
      LISTS.upgrade.innerHTML = '';
      Object.keys(UPGRADE_DEFS).forEach(key => {
        const def = UPGRADE_DEFS[key]; const lv = state.upgrades[key] || 0;
        const cost = calcUpgradeCost(key, lv);
        const maxed = lv >= def.max;
        const row = document.createElement('div');
        row.className = 'up-row';
        row.innerHTML = `
      <div class="up-left">
        <span>${def.icon}</span>
        <div>
          <div class="up-name">${def.name}</div>
          <div class="up-level">Lv ${lv}/${def.max}</div>
          <div class="up-cost">${maxed ? 'ìµœëŒ€ ê°•í™”' : `ë¹„ìš©: ${cost}G`}</div>
        </div>
      </div>
      <div>
        <button class="modal-btn" data-up="${key}" ${maxed ? 'disabled' : ''}>ê°•í™”</button>
      </div>
    `;
        LISTS.upgrade.appendChild(row);
        const btn = row.querySelector('button');
        btn.onclick = () => {
          if (maxed) { playSfx('sfxError'); return; }
          if (state.gold < cost) { playSfx('sfxError'); alert('ê³¨ë“œê°€ ë¶€ì¡±í•©ë‹ˆë‹¤!'); return; }
          state.gold -= cost;
          state.upgrades[key] = lv + 1;
          saveMeta(); updateUI(); renderUpgrades(); playSfx('sfxBuy');
        };
      });
    }

    function renderLeaderboard() {
      const scores = loadScores();
      LISTS.rank.innerHTML = scores.length ? '' : '<div class="small">ê¸°ë¡ì´ ì—†ìŠµë‹ˆë‹¤.</div>';
      scores.forEach((e, i) => {
        const div = document.createElement('div');
        div.style.padding = '6px 0';
        div.innerHTML = `<b>${i + 1}ìœ„</b> Â· ${e.nick} Â· <b>${e.score}</b>ì  Â· ìŠ¤í…Œì´ì§€ ${e.stage} Â· LV ${e.level} Â· ${e.survive}s`;
        LISTS.rank.appendChild(div);
      });
    }

    function renderCustomization() {
      LISTS.colorGrid.innerHTML = '';
      CUSTOMIZATION.colors.forEach(c => {
        const item = document.createElement('div');
        item.className = 'customize-item' + (state.customization.color === c.id ? ' selected' : '');
        item.innerHTML = `<div style="width:40px;height:40px;margin:0 auto;border-radius:50%;background:linear-gradient(135deg,${c.start},${c.end})"></div><div class="small">${c.name}</div>`;
        item.onclick = () => {
          state.customization.color = c.id;
          saveMeta();
          applyCharacter();
          renderCustomization();
          playSfx('sfxBtn');
        };
        LISTS.colorGrid.appendChild(item);
      });

      LISTS.weaponGrid.innerHTML = '';
      CUSTOMIZATION.weapons.forEach(w => {
        const item = document.createElement('div');
        item.className = 'customize-item' + (state.customization.weapon === w.id ? ' selected' : '');
        item.innerHTML = `<div style="width:30px;height:30px;margin:0 auto;border-radius:50%;background:${w.color}"></div><div class="small">${w.name}</div>`;
        item.onclick = () => {
          state.customization.weapon = w.id;
          saveMeta();
          renderCustomization();
          playSfx('sfxBtn');
        };
        LISTS.weaponGrid.appendChild(item);
      });

      LISTS.effectGrid.innerHTML = '';
      CUSTOMIZATION.effects.forEach(ef => {
        const item = document.createElement('div');
        item.className = 'customize-item' + (state.customization.effect === ef.id ? ' selected' : '');
        item.innerHTML = `<div class="small">${ef.name}</div>`;
        item.onclick = () => {
          state.customization.effect = ef.id;
          saveMeta();
          applyCharacter();
          renderCustomization();
          playSfx('sfxBtn');
        };
        LISTS.effectGrid.appendChild(item);
      });
    }

    function scoreToGold(score) { return Math.floor(score * 0.10); }

    // =========================
    // ê²Œì„ ì˜¤ë²„
    // =========================
    function gameOver() {
      if (state.screen === 'gameover') return;
      state.screen = 'gameover'; state.running = false;
      stopBgm(); // BGM ì •ì§€
      playSfx('sfxLose');

      checkAchievements();

      const goldEarn = scoreToGold(state.score);
      state.gold += goldEarn; saveMeta();

      document.getElementById('finalStats').innerHTML =
        `ë‹‰ë„¤ì„: ${state.nick}<br>ìµœì¢… ë ˆë²¨: ${state.level}<br>ìŠ¤í…Œì´ì§€: ${state.stage}<br>ì²˜ì¹˜: ${state.kills} (ë³´ìŠ¤ ${state.bossKills}, ì—˜ë¦¬íŠ¸ ${state.eliteKills})<br>ì ìˆ˜: ${Math.floor(state.score)}<br>ìƒì¡´: ${state.surviveSec}s`;
      LISTS.earnedGold.textContent = `íšë“ ê³¨ë“œ: +${goldEarn}G (ì´ ${state.gold}G)`;

      addScoreRecord({
        nick: state.nick,
        score: Math.floor(state.score),
        stage: state.stage,
        level: state.level,
        survive: state.surviveSec,
        ts: Date.now()
      });

      renderEarnedAchievements();
      MODALS.gameOver.style.display = 'block';
    }

    function checkAchievements() {
      const snap = {
        kills: state.kills,
        stage: state.stage,
        surviveSec: state.surviveSec,
        bossKills: state.bossKills,
        eliteKills: state.eliteKills
      };
      let got = false;
      ACHIEVEMENTS.forEach(a => {
        if (!state.achievements[a.id] && a.cond(snap)) {
          state.achievements[a.id] = true;
          const b = document.createElement('div'); b.className = 'badge'; b.textContent = 'ğŸ† ' + a.name;
          b.style.position = 'absolute'; b.style.top = '10px'; b.style.left = '10px'; b.style.background = 'rgba(0,0,0,.8)';
          b.style.border = '2px solid #ffd700'; b.style.zIndex = '1500'; b.style.fontSize = '16px';
          game.appendChild(b); setTimeout(() => b.remove(), 2000);
          got = true;
        }
      });
      if (got) { playSfx('sfxPick'); saveMeta(); }
    }

    function renderEarnedAchievements() {
      LISTS.achieveRow.innerHTML = '';
      if (Object.keys(state.achievements).length === 0) {
        LISTS.achieveRow.innerHTML = '<div class="small">ë‹¬ì„±í•œ ì—…ì ì´ ì—†ìŠµë‹ˆë‹¤</div>';
        return;
      }
      Object.entries(state.achievements).forEach(([id, ok]) => {
        if (ok) {
          const a = ACHIEVEMENTS.find(x => x.id === id);
          const tag = document.createElement('div'); tag.className = 'badge';
          tag.textContent = 'ğŸ† ' + (a ? a.name : id);
          tag.style.background = 'rgba(255,215,0,.2)';
          tag.style.border = '1px solid #ffd700';
          LISTS.achieveRow.appendChild(tag);
        }
      });
    }

    // =========================
    // ë²„íŠ¼ ì´ë²¤íŠ¸
    // =========================
    BTN.introStart.onclick = () => { playSfx('sfxBtn'); openMenu(); };
    BTN.introTutorial.onclick = () => { playSfx('sfxBtn'); showModal('tutorial'); state.screen = 'tutorial'; };
    BTN.tutorialBack.onclick = () => { playSfx('sfxBtn'); openIntro(); };

    BTN.start.onclick = () => {
      state.nick = (INPUTS.nick.value || 'Guest').trim().slice(0, 12) || 'Guest';
      UI.nickLabel.textContent = state.nick;
      const wantChar = INPUTS.char.value;
      if (state.unlocks[wantChar]) state.character = wantChar;
      saveMeta(); playSfx('sfxBtn'); startGame();
    };
    BTN.customize.onclick = () => { playSfx('sfxBtn'); showModal('customize'); state.screen = 'customize'; };
    BTN.settings.onclick = () => { playSfx('sfxBtn'); showModal('settings'); state.screen = 'settings'; };
    BTN.leaderboard.onclick = () => { playSfx('sfxBtn'); showModal('leaderboard'); state.screen = 'leaderboard'; };
    BTN.shop.onclick = () => { playSfx('sfxBtn'); showModal('shop'); state.screen = 'shop'; };
    BTN.lbBack.onclick = () => { playSfx('sfxBtn'); openMenu(); };
    BTN.shopBack.onclick = () => { playSfx('sfxBtn'); openMenu(); };
    BTN.customizeBack.onclick = () => { playSfx('sfxBtn'); openMenu(); };
    BTN.settingsBack.onclick = () => { playSfx('sfxBtn'); openMenu(); };
    BTN.resumeGame.onclick = () => { playSfx('sfxBtn'); resumeGame(); };
    BTN.restart.onclick = () => { playSfx('sfxBtn'); startGame(); };
    BTN.goMenu.onclick = () => { playSfx('sfxBtn'); openMenu(); };

    INPUTS.bgmVol.oninput = () => { setBgmVolume(Number(INPUTS.bgmVol.value)); saveSettings(); };
    INPUTS.sfxVol.oninput = () => { setSfxVolume(Number(INPUTS.sfxVol.value)); saveSettings(); };

    // =========================
    // ì´ˆê¸°í™”
    // =========================
    function init() {
      initAudio();
      loadSave();
      INPUTS.nick.value = state.nick;
      INPUTS.char.value = state.character;
      updateCharacterSelect();
      applyCharacter();
      openIntro();
    }
    init();
  </script>
</body>

</html>